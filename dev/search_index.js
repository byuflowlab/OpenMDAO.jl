var documenterSearchIndex = {"docs":
[{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"nonlinear_circuit/#A-More-Complicated-Example:-Nonlinear-Circuit","page":"A More Complicated Example","title":"A More Complicated Example: Nonlinear Circuit","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"This tutorial will implement the nonlinear circuit example from the OpenMDAO docs in Julia. Along the way, we'll learn","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"how to create implicit components with OpenMDAO.jl\nhow to create OpenMDAO.jl components with metadata (the equivalent of options in a normal Python component)\nhow to specify default values for component metadata","category":"page"},{"location":"nonlinear_circuit/#Preamble","page":"A More Complicated Example","title":"Preamble","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We'll need the OpenMDAOCore package, of course:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"using OpenMDAOCore: OpenMDAOCore","category":"page"},{"location":"nonlinear_circuit/#An-Explicit-Component-with-an-Option:-The-Resistor","page":"A More Complicated Example","title":"An Explicit Component with an Option: The Resistor","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next we'll create an explicit component that models a resistor. The resistor has one option: the resistance, R. We'll make R a field in the Julia struct that we'll use for the Resistor component:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Resistor <: OpenMDAOCore.AbstractExplicitComp\n    R::Float64\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Now we'd like to use a default value of 1.0 for the resistance. We can do that by creating an outer constructor for the Resistor struct with a default keyword value.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"# Default value for R.\nResistor(; R=1.0) = Resistor(R)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll create a setup function as usual:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Resistor)\n    input_data = [OpenMDAOCore.VarData(\"V_in\"; units=\"V\"), OpenMDAOCore.VarData(\"V_out\"; units=\"V\")]\n    output_data = [OpenMDAOCore.VarData(\"I\"; units=\"A\")]\n\n    R = self.R\n    partials_data = [OpenMDAOCore.PartialsData(\"I\", \"V_in\", val=1/R),\n                     OpenMDAOCore.PartialsData(\"I\", \"V_out\", val=-1/R),]\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Since this is a linear resistor, the derivatives are constant, and we can set them via the val argument in the PartialsData struct, just like in OpenMDAO's declare_partials method. Also notice that we can specify units for each of the inputs and outputs, just like in a Python OpenMDAO component.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, we'll implement the compute! method:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.compute!(self::Resistor, inputs, outputs)\n    deltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n    outputs[\"I\"][1] = deltaV/self.R\n\n    return nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Notice that we have access to the R field in the Resistor struct, named self here. (We could call it anything, just like in a Python method.)","category":"page"},{"location":"nonlinear_circuit/#An-Explicit-Component-with-Two-Options:-The-Diode","page":"A More Complicated Example","title":"An Explicit Component with Two Options: The Diode","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We need two parameters to characterize the Diode: the saturation current Is and the thermal voltage Vt:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Diode <: OpenMDAOCore.AbstractExplicitComp\n    Is::Float64\n    Vt::Float64\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll create an constructor that sets both options using keyword arguments, and provides default values for both.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"# Use Julia's keyword arguments to set default values.\nDiode(; Is=1e-15, Vt=0.025875) = Diode(Is, Vt)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll implement the setup method for the Diode.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Diode)\n    input_data = [OpenMDAOCore.VarData(\"V_in\"; units=\"V\"), OpenMDAOCore.VarData(\"V_out\"; units=\"V\")]\n    output_data = [OpenMDAOCore.VarData(\"I\"; units=\"A\")]\n\n    partials_data = [OpenMDAOCore.PartialsData(\"I\", \"V_in\"), OpenMDAOCore.PartialsData(\"I\", \"V_out\")]\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Nothing unusual here.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, the compute! and compute_partials! methods:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.compute!(self::Diode, inputs, outputs)\n    deltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n\tIs = self.Is\n\tVt = self.Vt\n    outputs[\"I\"][1] = Is * (exp(deltaV / Vt) - 1)\n    return nothing\nend\n\nfunction OpenMDAOCore.compute_partials!(self::Diode, inputs, J)\n\tdeltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n\tIs = self.Is\n\tVt = self.Vt\n\tI = Is * exp(deltaV / Vt)\n\n\tJ[\"I\", \"V_in\"][1, 1] = I/Vt\n\tJ[\"I\", \"V_out\"][1, 1] = -I/Vt\n\n\treturn nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Like the Resistor, we have access to the Is and Vt options in the Diode struct in both methods.","category":"page"},{"location":"nonlinear_circuit/#Our-First-Implicit-Component:-The-Node","page":"A More Complicated Example","title":"Our First Implicit Component: The Node","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Our final component we need for the circuit is an implicit one: the Node. Each node can have an arbitrary number of incoming and outgoing currents, so we'll need two integer options to keep track of that:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Node <: OpenMDAOCore.AbstractImplicitComp\n    n_in::Int\n\tn_out::Int\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We'll have n_in and n_out both default to one, though:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Node(; n_in=1, n_out=1) = Node(n_in, n_out)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next up is the setup method. We'll need to use a loop to create all the inputs and outputs needed for the component:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Node)\n    output_data = [OpenMDAOCore.VarData(\"V\", val=5.0, units=\"V\")]\n\n    input_data = Vector{OpenMDAOCore.VarData}()\n    partials_data = Vector{OpenMDAOCore.PartialsData}()\n\n\tfor i in 0:self.n_in-1\n        i_name = \"I_in:$i\"\n        push!(input_data, OpenMDAOCore.VarData(i_name; units=\"A\"))\n        push!(partials_data, OpenMDAOCore.PartialsData(\"V\", i_name; val=1.0))\n\tend\n\n\tfor i in 0:self.n_out-1\n        i_name = \"I_out:$i\"\n        push!(input_data, OpenMDAOCore.VarData(i_name; units=\"A\"))\n        push!(partials_data, OpenMDAOCore.PartialsData(\"V\", i_name; val=-1.0))\n\tend\n\n\treturn input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We could have done something fancier like an array comprehension to create the VarData and PartialsData structs:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"input_data = [OpenMDAOCore.VarData(\"I_in:$i\"; units=\"A\") for i in 0:self.n_in-1]","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Also, the derivatives are constant for the node, so we set them in the PartialsData struct.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, we just need to write the apply_nonlinear! method:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.apply_nonlinear!(self::Node, inputs, outputs, residuals)\n    residuals[\"V\"][1] = 0.0\n    for i_conn in 0:self.n_in-1\n        residuals[\"V\"][1] += inputs[\"I_in:$i_conn\"][1]\n    end\n    for i_conn in 0:self.n_out-1\n        residuals[\"V\"][1] -= inputs[\"I_out:$i_conn\"][1]\n    end\n\n    return nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We see that the apply_nonlinear! OpenMDAO.jl method is very similar to the apply_nonlinear method on a normal Python ImplicitComponent— its job is to calculate the residual of the implicit equation(s) it is modeling from the inputs and outputs.","category":"page"},{"location":"nonlinear_circuit/#The-Run-Script","page":"A More Complicated Example","title":"The Run Script","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We're finally ready for the run script! Here it is:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"using OpenMDAO: om, make_component\n\np = om.Problem()\n\ncircuit = om.Group()\n\ncircuit.add_subsystem(\"n1\", make_component(Node(n_in=1, n_out=2)), promotes_inputs=[(\"I_in:0\", \"I_in\")])\ncircuit.add_subsystem(\"n2\", make_component(Node()))\n\ncircuit.add_subsystem(\"R1\", make_component(Resistor(R=100.0)), promotes_inputs=[(\"V_out\", \"Vg\")])\ncircuit.add_subsystem(\"R2\", make_component(Resistor(R=10000.0)))\ncircuit.add_subsystem(\"D1\", make_component(Diode()), promotes_inputs=[(\"V_out\", \"Vg\")])\n\ncircuit.connect(\"n1.V\", [\"R1.V_in\", \"R2.V_in\"])\ncircuit.connect(\"R1.I\", \"n1.I_out:0\")\ncircuit.connect(\"R2.I\", \"n1.I_out:1\")\n\ncircuit.connect(\"n2.V\", [\"R2.V_out\", \"D1.V_in\"])\ncircuit.connect(\"R2.I\", \"n2.I_in:0\")\ncircuit.connect(\"D1.I\", \"n2.I_out:0\")\n\ncircuit.nonlinear_solver = om.NewtonSolver()\ncircuit.linear_solver = om.DirectSolver()\n\ncircuit.nonlinear_solver.options[\"iprint\"] = 2\ncircuit.nonlinear_solver.options[\"maxiter\"] = 10\ncircuit.nonlinear_solver.options[\"solve_subsystems\"] = true\ncircuit.nonlinear_solver.linesearch = om.ArmijoGoldsteinLS()\ncircuit.nonlinear_solver.linesearch.options[\"maxiter\"] = 10\ncircuit.nonlinear_solver.linesearch.options[\"iprint\"] = 2\n\np.model.add_subsystem(\"circuit\", circuit)\n\np.setup()\n\np.set_val(\"circuit.I_in\", 0.1)\np.set_val(\"circuit.Vg\", 0.)\n\n# set some initial guesses\np.set_val(\"circuit.n1.V\", 10.)\np.set_val(\"circuit.n2.V\", 1e-3)\n\np.run_model()\n\nprintln(\"circuit.n1.V = $(p[\"circuit.n1.V\"]) (should be 9.90804735)\")\nprintln(\"circuit.n2.V = $(p[\"circuit.n2.V\"]) (should be 0.71278185)\")\nprintln(\"circuit.R1.I = $(p[\"circuit.R1.I\"]) (should be 0.09908047)\")\nprintln(\"circuit.R2.I = $(p[\"circuit.R2.I\"]) (should be 0.00091953)\")\nprintln(\"circuit.D1.I = $(p[\"circuit.D1.I\"]) (should be 0.00091953)\")\n\n# sanity check: should sum to .1 Amps\nprintln(\"circuit.R1.I + circuit.D1.I = $(p[\"circuit.R1.I\"] + p[\"circuit.D1.I\"]) (should be 0.1)\")","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Notice that:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We can use Groups and connect methods just like a Python OpenMDAO program\nLinear and nonlinear solvers, and linesearch objects also work fine\nWe get the same answers as the Python example in the OpenMDAO docs! :-)","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"dev_docs/#Developer-Docs","page":"Developer Docs","title":"Developer Docs","text":"","category":"section"},{"location":"dev_docs/#How-to-Release-a-New-Version","page":"Developer Docs","title":"How to Release a New Version","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"For either OpenMDAOCore.jl or OpenMDAO.jl, registering a new version should be as simple as commenting","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"@JuliaRegistrator register subdir=julia/OpenMDAOCore.jl","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"or","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"@JuliaRegistrator register subdir=julia/OpenMDAO.jl","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"on a new issue, like here. Be sure to adjust the version field in the appropriate Project.toml before you do that. And after the new version is registered, don't forget to tag it as suggested by the JuliaRegistrator bot. For example, OpenMDAOCore.jl version 0.3.1 was tagged like this:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ git tag OpenMDAOCore.jl-v0.3.1 ea03a4e1be02a989021e5b466fc1fe51534e6fdb\n$ git push upstream OpenMDAOCore.jl-v0.3.1","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"where upstream is the remote corresponding to byuflowlab/OpenMDAO.jl.git:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ git remote -v\norigin  git@github.com:dingraha/OpenMDAO.jl.git (fetch)\norigin  git@github.com:dingraha/OpenMDAO.jl.git (push)\nupstream        git@github.com:byuflowlab/OpenMDAO.jl.git (fetch)\nupstream        git@github.com:byuflowlab/OpenMDAO.jl.git (push)\n$","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"For omjlcomps, registration is done by manually running the \"Register to PyPI\" workflow from the GitHub Actions tab (basically copied from PythonCall.jl). Be sure to adjust the version in the python/setup.py file before registering a new version. After clicking on the Actions tab on https://github.com/byuflowlab/OpenMDAO.jl, you'll see \"Register to PyPI\" listed under \"All workflows\" on the left-hand side. Click on that, then click on the \"Run workflow\" dropdown button on the right-hand side of the screen. Run it from the master branch, then wait for the workflow to finish. After that, you should see the new version of omjlcomps on PyPI: https://pypi.org/project/omjlcomps/. Once that's done, tag the commit that contains the new version of omjlcomps and push that to byuflowlab/OpenMDAO.jl.git. For example, omjlcomps version 0.2.3 was tagged with","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ git tag omjlcomps-v0.2.3 d7830552dc3d54fe18b89dc91b36219739d13a62\n$ git push upstream omjlcomps-v0.2.3","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"where upstream is the remote corresponding to byuflowlab/OpenMDAO.jl.git:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ git remote -v\norigin  git@github.com:dingraha/OpenMDAO.jl.git (fetch)\norigin  git@github.com:dingraha/OpenMDAO.jl.git (push)\nupstream        git@github.com:byuflowlab/OpenMDAO.jl.git (fetch)\nupstream        git@github.com:byuflowlab/OpenMDAO.jl.git (push)\n$","category":"page"},{"location":"dev_docs/#How-to-Release-a-New-Version-(Old,-LocalRegistry-Way)","page":"Developer Docs","title":"How to Release a New Version (Old, LocalRegistry Way)","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"Note This section of the docs describes how I released new versions of OpenMDAO{,Core}.jl and omjlcomps before getting stuff registered in the Julia General registry. They are outdated and unnecessary, but I'm keeping them for now in case someone wants to do something similar down the road.","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"It's a bit tricky to release a new version of OpenMDAO.jl, since this repository contains 3 separate software packages: the Julia packages OpenMDAOCore.jl and OpenMDAO.jl, and the Python package omjlcomps. Here's how to do it.","category":"page"},{"location":"dev_docs/#Step-1:-Hack-on-OpenMDAO.jl","page":"Developer Docs","title":"Step 1: Hack on OpenMDAO.jl","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"The first step of releasing a new version is obviously hacking on the code, which is no different than working on any other piece of software on GitHub. You'll need to fork the byuflowlab/OpenMDAO.jl GitHub repository, then clone it to your local machine with","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ git clone git@github.com:<your_user_name>/OpenMDAO.jl.git","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"Then you can start making changes, hopefully in a new local feature branch you create.","category":"page"},{"location":"dev_docs/#Step-2:-Submit-a-PR-to-byuflowlab/OpenMDAO.jl.git-and-merge","page":"Developer Docs","title":"Step 2: Submit a PR to byuflowlab/OpenMDAO.jl.git and merge","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"After you're happy with your changes (they have tests, right? And pass those tests?), push your local changes to your GitHub fork, and then submit a PR to byuflowlab/OpenMDAO.jl.git. Be sure to bump the version number in each sub-package appropriately (if necessary: no need to modify all three version numbers just because a change was made to only one or two of the packages). The OpenMDAOCore.jl and OpenMDAO.jl version numbers should follow semantic versioning (check out the Julia Pkg docs on compatibility). I try to follow semantic versioning with the omjlcomps Python package, even though semantic versioning doesn't appear to be as pervasive in the Python ecosystem as it is in Julia land.","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"After everyone is satisfied with the PR, an Administrator of the byuflowab/OpenMDAO.jl repository will merge the package.","category":"page"},{"location":"dev_docs/#Step-3:-Tag-the-new-version(s)","page":"Developer Docs","title":"Step 3: Tag the new version(s)","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"Every time the version of any of the three OpenMDAO.jl sub-packages is bumped, we should tag a new version. The way to do this is the following:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"First, check out the upstream master branch, i.e. if the remote branch pointing to byuflowlab/OpenMDAO.jl.git is upstream, then do git checkout upstream/master. That should put the local repository in a \"detached HEAD\" state, like this:\n$ git checkout upstream/master\nNote: switching to 'upstream/master'.\n\nYou are in 'detached HEAD' state. You can look around, make experimental\nchanges and commit them, and you can discard any commits you make in this\nstate without impacting any branches by switching back to a branch.\n\nIf you want to create a new branch to retain commits you create, you may\ndo so (now or later) by using -c with the switch command. Example:\n\n  git switch -c <new-branch-name>\n\nOr undo this operation with:\n\n  git switch -\n\nTurn off this advice by setting config variable advice.detachedHead to false\n\nHEAD is now at a9e8f78 Merge pull request #16 from dingraha/licence\n$\nMake sure you're on the commit corresponding to the merged pull request you want to release/tag, using, for example, git log -n1:\n$ git log -n 1\ncommit a9e8f7849844640f77a2eadd3683476be92ba8fb (HEAD, upstream/master, origin/master, origin/HEAD, master, how_to_release)\nMerge: 16f0355 054b78c\nAuthor: Daniel Ingraham <d.j.ingraham@gmail.com>\nDate:   Thu May 25 09:02:07 2023 -0400\n\n    Merge pull request #16 from dingraha/licence\n    \n    Add LICENSE\n$ \nCreate the tag(s) using git tag. The tag or tags should follow the format package_name-vX.Y.Z. For example, here are the tags at the time of writing:\n$ git tag\nOpenMDAO.jl-v0.3.0\nOpenMDAO.jl-v0.3.1\nOpenMDAO.jl-v0.3.2\nOpenMDAO.jl-v0.4.0\nOpenMDAOCore.jl-v0.2.10\nOpenMDAOCore.jl-v0.2.8\nOpenMDAOCore.jl-v0.2.9\nOpenMDAOCore.jl-v0.3.0\nomjlcomps-v0.1.7\nomjlcomps-v0.1.8\nomjlcomps-v0.1.9\nomjlcomps-v0.2.0\nv0.2.0\nv0.2.1\n$ \n(The v0.2.0 and v0.2.1 tags are from very early versions of OpenMDAO.jl and don't follow the recomended tag format.)\nWith the tags created, all that's left is to push them to upstream:\n$ git push --tags upstream","category":"page"},{"location":"dev_docs/#Step-4:-Release-the-new-version(s)-to-the-appropriate-registries","page":"Developer Docs","title":"Step 4: Release the new version(s) to the appropriate registries","text":"","category":"section"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"For either of the two Julia packages (OpenMDAO.jl and OpenMDAOCore.jl), we need to register a new version with DanielIngrahamRegistry at dingraha/DanielIngrahamRegistry on GitHub using LocalRegistry. Again, this is unfortunately something only I (Daniel) can do. All that needs to be done is, from the Julia REPL:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"Make sure you've deved the package you want to release, and are on the appropriate commit.\nDo LocalRegistry.register(\"OpenMDAOCore\") and/or LocalRegistry.register(\"OpenMDAO\"), as appropriate.","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"If a new version of omjlcomps was tagged, then we need to put it on PyPI. The way I do this currently is using twine:","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"$ # In the OpenMDAO.jl/python directory.\n$ python setup.py sdist\nrunning sdist\nrunning egg_info\nwriting omjlcomps.egg-info/PKG-INFO\nwriting dependency_links to omjlcomps.egg-info/dependency_links.txt\nwriting entry points to omjlcomps.egg-info/entry_points.txt\nwriting requirements to omjlcomps.egg-info/requires.txt\nwriting top-level names to omjlcomps.egg-info/top_level.txt\nreading manifest file 'omjlcomps.egg-info/SOURCES.txt'\nreading manifest template 'MANIFEST.in'\nwriting manifest file 'omjlcomps.egg-info/SOURCES.txt'\nrunning check\ncreating omjlcomps-0.1.9\ncreating omjlcomps-0.1.9/omjlcomps\ncreating omjlcomps-0.1.9/omjlcomps.egg-info\ncreating omjlcomps-0.1.9/omjlcomps/test\ncopying files to omjlcomps-0.1.9...\ncopying MANIFEST.in -> omjlcomps-0.1.9\ncopying README.md -> omjlcomps-0.1.9\ncopying setup.py -> omjlcomps-0.1.9\ncopying omjlcomps/__init__.py -> omjlcomps-0.1.9/omjlcomps\ncopying omjlcomps/juliapkg.json -> omjlcomps-0.1.9/omjlcomps\ncopying omjlcomps.egg-info/PKG-INFO -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps.egg-info/SOURCES.txt -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps.egg-info/dependency_links.txt -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps.egg-info/entry_points.txt -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps.egg-info/requires.txt -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps.egg-info/top_level.txt -> omjlcomps-0.1.9/omjlcomps.egg-info\ncopying omjlcomps/test/__init__.py -> omjlcomps-0.1.9/omjlcomps/test\ncopying omjlcomps/test/test_ecomp.jl -> omjlcomps-0.1.9/omjlcomps/test\ncopying omjlcomps/test/test_icomp.jl -> omjlcomps-0.1.9/omjlcomps/test\ncopying omjlcomps/test/test_julia_explicit_comp.py -> omjlcomps-0.1.9/omjlcomps/test\ncopying omjlcomps/test/test_julia_implicit_comp.py -> omjlcomps-0.1.9/omjlcomps/test\nWriting omjlcomps-0.1.9/setup.cfg\nCreating tar archive\nremoving 'omjlcomps-0.1.9' (and everything under it)\n(venv) dingraha@GRLRL2021060743 ~/p/p/d/O/python (master %)> ls\nbuild/  dist/  MANIFEST.in  omjlcomps/  omjlcomps.egg-info/  README.md  setup.py\n(venv) dingraha@GRLRL2021060743 ~/p/p/d/O/python (master %)> twine upload dist/omjlcomps-0.1.9.tar.gz \nUploading distributions to https://upload.pypi.org/legacy/\nEnter your username: dingraha\nEnter your password: \nUploading omjlcomps-0.1.9.tar.gz\n100% ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 12.1/12.1 kB • 00:00 • 8.5 MB/s\n\nView at:\nhttps://pypi.org/project/omjlcomps/0.1.9/\n$ ","category":"page"},{"location":"dev_docs/","page":"Developer Docs","title":"Developer Docs","text":"That unfortunately is something only I can do, since it requires my username and password for PyPI. Also it uses plain password authentication, which I think isn't supported anymore, or won't be for long.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"simple_paraboloid/#A-Simple-Example:-Optimizing-a-Paraboloid","page":"A Simple Example","title":"A Simple Example: Optimizing a Paraboloid","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We're going to duplicate the Paraboloid example from the OpenMDAO documentation, but implement the single ExplicitComponent in Julia instead of Python. The goal of this tutorial is to minimize the paraboloid","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"f(xy) = (x - 30)^2 + xy + (y + 40)^2 - 30","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"with respect to x and y. The OpenMDAO docs say the answer is x = frac203 approx 6667 and y = -frac223 approx -7333. Let's find out!","category":"page"},{"location":"simple_paraboloid/#The-Python-Implementation","page":"A Simple Example","title":"The Python Implementation","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"One possible Python implementation of the above paraboloid is this:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"import openmdao.api as om\n\n\nclass Paraboloid(om.ExplicitComponent):\n    \"\"\"\n    Evaluates the equation f(x,y) = (x-3)^2 + xy + (y+4)^2 - 3.\n    \"\"\"\n\n    def setup(self):\n        self.add_input('x', val=0.0)\n        self.add_input('y', val=0.0)\n\n        self.add_output('f_xy', val=0.0)\n\n        # Finite difference all partials.\n        self.declare_partials('*', '*', method='fd')\n\n    def compute(self, inputs, outputs):\n        \"\"\"\n        f(x,y) = (x-3)^2 + xy + (y+4)^2 - 3\n\n        Minimum at: x = 6.6667; y = -7.3333\n        \"\"\"\n        x = inputs['x']\n        y = inputs['y']\n\n        outputs['f_xy'] = (x - 3.0)**2 + x * y + (y + 4.0)**2 - 3.0","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Not too bad. How do we do it in Julia?","category":"page"},{"location":"simple_paraboloid/#The-Julia-Implementation","page":"A Simple Example","title":"The Julia Implementation","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Like this, using OpenMDAOCore.jl:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore\n\nstruct Paraboloid <: OpenMDAOCore.AbstractExplicitComp\nend\n\nfunction OpenMDAOCore.setup(self::Paraboloid)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\", method=\"fd\")]\n    return inputs, outputs, partials\nend\n\nfunction OpenMDAOCore.compute!(self::Paraboloid, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"What does all that mean? We'll go through it step by step.","category":"page"},{"location":"simple_paraboloid/#Step-1:-Preamble","page":"A Simple Example","title":"Step 1: Preamble","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This line loads the OpenMDAOCore.jl Julia package. Julia uses two different keywords for loading code from Julia modules: using and import. The official Julia docs on Modules do a good job of explaining the difference. I like doing using Foo: Foo because it brings the module name Foo into the current scope, but not any of the names inside of Foo, so it doesn't clutter the namespace. (The statement using Foo: Foo is kind of like Julia's version of import foo in Python, while just plain using Foo is like Python's from foo import *.)","category":"page"},{"location":"simple_paraboloid/#Step-2:-The-Paraboloid-struct","page":"A Simple Example","title":"Step 2: The Paraboloid struct","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"struct Paraboloid <: OpenMDAOCore.AbstractExplicitComp\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This bit of code defines a new type in Julia named Paraboloid. The <: is the subtype operator in Julia, so we are telling Julia that our new Paraboloid type is a subtype of the AbstractExplicitComp type defined in OpenMDAOCore. This is the Julian equivalent of","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"class Paraboloid(om.ExplicitComponent):","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"in Python.","category":"page"},{"location":"simple_paraboloid/#Step-3:-OpenMDAOCore.setup","page":"A Simple Example","title":"Step 3: OpenMDAOCore.setup","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"function OpenMDAOCore.setup(self::Paraboloid)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\", method=\"fd\")]\n    return inputs, outputs, partials\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This OpenMDAOCore.setup method is the Julian equivalent of the ExplicitComponent.setup method from the Python version of the paraboloid. The job of OpenMDAOCore.setup is to take a single argument (an OpenMDAOCore.AbstractExplicitComp or OpenMDAOCore.AbstractImplicitComp) and return three things:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"A Vector of VarData structs containing metadata for the inputs to the component\nA Vector of VarData structs containing metadata for the outputs of the component\nA Vector of PartialsData structs containing metadata for the partial derivatives of the component","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"These Julia Vectors must always be returned in that order: inputs, outputs, partials. OpenMDAO.jl uses the VarData entries in the inputs and outputs Vectors to construct arguments to the Component.add_input and Component.add_output, respectively. And OpenMDAO.jl uses the PartialsData entries in the partials Vector to construct arguments to Component.declare_partials. The OpenMDAOCore.VarData and OpenMDAOCore.PartialsData docstrings have all the details.","category":"page"},{"location":"simple_paraboloid/#Step-4:-OpenMDAOCore.compute!","page":"A Simple Example","title":"Step 4: OpenMDAOCore.compute!","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"function OpenMDAOCore.compute!(self::Paraboloid, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This OpenMDAOCore.compute! method is the equivalent of the Paraboloid.compute method from the Python version of the Paraboloid. Its job is to take a Paraboloid struct and a Dict of inputs, calculate the outputs, and then store these outputs in the outputs Dict. The inputs and outputs Dict entries are Julia arrays, similar to the NumPy arrays that OpenMDAO uses. (They are actually PyArrays from the PythonCall package, which are wrappers around the NumPy arrays that OpenMDAO creates for us.)","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now we need to figure out how to get that Julia code into OpenMDAO. How we do that depends on whether we're following the Python-Centric Approach or Julia-Centric Approach.","category":"page"},{"location":"simple_paraboloid/#The-Python-Centric-Run-Script","page":"A Simple Example","title":"The Python-Centric Run Script","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We'll use JuliaCall, provided by the PythonCall package, to import the Julia code from the previous section into Python. Then we can use the omjlcomps Python package to create an OpenMDAO ExplicitComponent from the Paraboloid Julia struct, and write a run script as usual.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"import openmdao.api as om\n\n# Create a new Julia module that will hold all the Julia code imported into this Python module.\nimport juliacall; jl = juliacall.newmodule(\"ParaboloidExample\")\n\n# This assumes the file with the Julia Paraboloid implementation is in the current directory and is named `paraboloid.jl`.\njl.include(\"paraboloid.jl\")\n# Now we have access to everything in `paraboloid.jl`.\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\nfrom omjlcomps import JuliaExplicitComp\ncomp = JuliaExplicitComp(jlcomp=jl.Paraboloid())\n\n# Now everything else is the same as https://openmdao.org/newdocs/versions/latest/basic_user_guide/single_disciplinary_optimization/first_analysis.html\nmodel = om.Group()\nmodel.add_subsystem('parab_comp', comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options['optimizer'] = 'SLSQP'\n\nprob.model.add_design_var('parab_comp.x')\nprob.model.add_design_var('parab_comp.y')\nprob.model.add_objective('parab_comp.f_xy')\n\nprob.setup()\n\nprob.set_val('parab_comp.x', 3.0)\nprob.set_val('parab_comp.y', -4.0)\n\nprob.run_model()\nprint(prob['parab_comp.f_xy'])  # Should print `[-15.]`\n\nprob.set_val('parab_comp.x', 5.0)\nprob.set_val('parab_comp.y', -2.0)\n\nprob.run_model()\nprint(prob.get_val('parab_comp.f_xy'))  # Should print `[-5.]`\n\nprob.run_driver()\nprint(f\"f_xy = {prob.get_val('parab_comp.f_xy')}\")  # Should print `[-27.33333333]`\nprint(f\"x = {prob.get_val('parab_comp.x')}\")  # Should print `[6.66666633]`\nprint(f\"y = {prob.get_val('parab_comp.y')}\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"The above Python run script should look pretty familiar if you have experience using OpenMDAO. The only difference from a pure-Python version is the little bit at the top that we use to create the JuliaExplicitComp.","category":"page"},{"location":"simple_paraboloid/#The-Julia-Centric-Run-Script","page":"A Simple Example","title":"The Julia-Centric Run Script","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now let's see if we can write a Julia run script:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAO: om, make_component\n\nprob = om.Problem()\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\ncomp = make_component(Paraboloid())\n\nmodel = om.Group()\nmodel.add_subsystem(\"parab_comp\", comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\n\nprob.model.add_design_var(\"parab_comp.x\")\nprob.model.add_design_var(\"parab_comp.y\")\nprob.model.add_objective(\"parab_comp.f_xy\")\n\nprob.setup()\n\nprob.set_val(\"parab_comp.x\", 3.0)\nprob.set_val(\"parab_comp.y\", -4.0)\n\nprob.run_model()\nprintln(prob[\"parab_comp.f_xy\"])  # Should print `[-15.]`\n\nprob.set_val(\"parab_comp.x\", 5.0)\nprob.set_val(\"parab_comp.y\", -2.0)\n\nprob.run_model()\nprintln(prob.get_val(\"parab_comp.f_xy\"))  # Should print `[-5.]`\n\nprob.run_driver()\nprintln(\"f_xy = $(prob.get_val(\"parab_comp.f_xy\"))\")  # Should print `[-27.33333333]`\nprintln(\"x = $(prob.get_val(\"parab_comp.x\"))\")  # Should print `[6.66666633]`\nprintln(\"y = $(prob.get_val(\"parab_comp.y\"))\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"(This example assumes that the definition of the Paraboloid struct is included in the same file. So concatenate those two code blocks if you'd like to run this yourself.) Good news—we got the expected answer!","category":"page"},{"location":"simple_paraboloid/#Adding-Derivatives","page":"A Simple Example","title":"Adding Derivatives","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"In the previous example we used OpenMDAO's finite difference method to approximate the paraboloid's partial derivatives. We can calculate them ourselves, though, just like in a Python OpenMDAO Component. Here's the implementation:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore\n\nstruct ParaboloidUserPartials <: OpenMDAOCore.AbstractExplicitComp\nend\n\nfunction OpenMDAOCore.setup(self::ParaboloidUserPartials)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\")]\n    return inputs, outputs, partials\nend\n\nfunction OpenMDAOCore.compute!(self::ParaboloidUserPartials, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend\n\nfunction OpenMDAOCore.compute_partials!(self::ParaboloidUserPartials, inputs, partials)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    partials[\"f_xy\", \"x\"][1] = 2*(x - 3.0) + y\n    partials[\"f_xy\", \"y\"][1] = x + 2*(y + 4.0)\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"The implementation of ParaboloidUserPartials is almost the same as Paraboloid. The are only two differences:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We've removed the method=\"fd\" argument from the call to the PartialsData constructor. This means the method argument will default to \"exact\" (as shown in the docstring above), and OpenMDAO will expect we'll calculate the derivatives of this component ourselves.\nWe've implemented a compute_partials! method for our new ParaboloidUserPartials struct. This is just like an ExplicitComponent.compute_partials method in a Python OpenMDAO component. Its job is to calculate the the derivatives of the outputs with respect to the inputs, of course.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"So, we implemented a compute_partials! method. But how do we know if they're right? The OpenMDAO Problem class has a method called check_partials that compares the user-defined partial derivatives to the finite difference method. Can we use that with an OpenMDAOCore.AbstractExplicitComp? Let's try!","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAO: om, make_component\n\nprob = om.Problem()\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\ncomp = make_component(ParaboloidUserPartials())\n\nmodel = om.Group()\nmodel.add_subsystem(\"parab_comp\", comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\n\nprob.model.add_design_var(\"parab_comp.x\")\nprob.model.add_design_var(\"parab_comp.y\")\nprob.model.add_objective(\"parab_comp.f_xy\")\n\nprob.setup(force_alloc_complex=true)\n\nprob.set_val(\"parab_comp.x\", 3.0)\nprob.set_val(\"parab_comp.y\", -4.0)\n\nprob.run_model()\nprintln(prob.check_partials(method=\"fd\"))","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"It worked! And the error is quite small.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"What about the complex step method?","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"println(prob.check_partials(method=\"cs\"))","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"It works! (The error is zero since the complex-step method is second-order accurate and we're differentiating a second-order polynomial.) Complex numbers are no problem for Julia, but just like Python, we need to be careful to write our compute_partials! function in a complex-step-safe manner.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"note: FLOWMath.jl\nThe Julia library FLOWMath has a collection of complex-step-safe functions.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now, let's try an optimization:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"prob.run_driver()\nprintln(\"f_xy = $(prob.get_val(\"parab_comp.f_xy\"))\")  # Should print `[-27.33333333]`\nprintln(\"x = $(prob.get_val(\"parab_comp.x\"))\")  # Should print `[6.66666633]`\nprintln(\"y = $(prob.get_val(\"parab_comp.y\"))\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Still works, and we got the right answer.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"shape_by_conn/#Variable-Shapes-at-Runtime:-shape_by_conn-and-copy_shape","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime: shape_by_conn and copy_shape","text":"","category":"section"},{"location":"shape_by_conn/#A-Simple-Example","page":"Variable Shapes at Runtime","title":"A Simple Example","text":"","category":"section"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"OpenMDAO is able to determine variable shapes at runtime. In \"normal\" (aka non-Julian) OpenMDAO, this is done via the shape_by_conn and copy_shape arguments to the venerable add_input and/or add_output Component methods. In OpenMDAO.jl, we can provide the shape_by_conn and/or copy_shape arguments to the VarData struct constructor to get the same behavior.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"We'll show how this works using a simple ExplicitComponent that computes y = 2*x^2 + 1 element-wise, where x and y are two-dimensional arrays of any (identical) size.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"We'll need OpenMDAOCore of course, and need to declare our ExplicitComponent in the usual way:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"using OpenMDAOCore: OpenMDAOCore\n\nstruct ECompShapeByConn <: OpenMDAOCore.AbstractExplicitComp end","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Next we need a setup method:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"function OpenMDAOCore.setup(self::ECompShapeByConn)\n    input_data = [OpenMDAOCore.VarData(\"x\"; shape_by_conn=true)]\n    output_data = [OpenMDAOCore.VarData(\"y\"; shape_by_conn=true, copy_shape=\"x\")]\n\n    partials_data = []\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Notice how we provided the shape_by_conn argument to the VarData struct for x, and the shape_by_conn and copy_shape arguments to y's VarData struct. This means that the shape of x will be determined at runtime by OpenMDAO, and will be set to the shape of whatever output is connected to x. The shape of y will be set to that of x, since we provided the copy_shape=\"x\" argument. (Also notice how we returned an empty Vector for the partials_data output—OpenMDAO.jl always expects OpenMDAOCore.setup to return three Vectors, corresponding to input_data, output_data, and partials_data. But the partials_data Vector can be empty if it's not needed.)","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, the derivative of y with respect to x will be sparse—the value of an element y[i,j] depends on the element x[i,j], and no others. We can communicate this fact to OpenMDAO through the rows and cols arguments to declare_partials in Python OpenMDAO, or the PartialsData struct in OpenMDAO.jl. But how do we do that here, when we don't know the sizes of x and y in the setup method? The answer is we implement an OpenMDAOCore.setup_partials method, which gives us another chance to create more PartialsData structs after OpenMDAO has figured out what the sizes of all the inputs and outputs are:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"function OpenMDAOCore.setup_partials(self::ECompShapeByConn, input_sizes, output_sizes)\n    @assert input_sizes[\"x\"] == output_sizes[\"y\"]\n    m, n = input_sizes[\"x\"]\n    rows, cols = OpenMDAOCore.get_rows_cols(ss_sizes=Dict(:i=>m, :j=>n), of_ss=[:i, :j], wrt_ss=[:i, :j])\n    partials_data = [OpenMDAOCore.PartialsData(\"y\", \"x\"; rows=rows, cols=cols)]\n\n    return partials_data\nend","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"The OpenMDAOCore.setup_partials method will always take an instance of the OpenMDAOCore.AbstractComp (called self here), and two Dicts, both with String keys and NTuple{N, Int} values. The keys indicate the name of an input or output variable, and the NTuple{Int, N} values are the shapes of each variable. The first Dict holds all the input shapes, and the second Dict has all the output shapes.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, the job of setup_partials is to return a Vector of PartialsData structs. We'd like to include the rows and cols arguments to the PartialsData struct for the derivative of y with respect to x, but it's a bit tricky, since x and y are two-dimensional. Luckily, there is a small utility function provided by OpenMDAOCore.jl called get_rows_cols that can help us.","category":"page"},{"location":"shape_by_conn/#Sparsity-Patterns-with-get_rows_cols","page":"Variable Shapes at Runtime","title":"Sparsity Patterns with get_rows_cols","text":"","category":"section"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"The get_rows_cols function uses a symbolic notation to express sparsity patterns in a simple way. Here's an example that corresponds to our present case. Let's say x and y have shape (2, 3). Then the non-zero index combinations for the derivative of y with respect to x will be (using zero-based indices, which is what OpenMDAO expects for the rows and cols arguments):","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"y indices:  x indices:\n(0, 0)      (0, 0)\n(0, 1)      (0, 1)\n(0, 2)      (0, 2)\n(1, 0)      (1, 0)\n(1, 1)      (1, 1)\n(1, 2)      (1, 2)","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"So that table says that the value of y[0, 0] depends on x[0, 0] only, and the value of y[1, 0] depends on x[1, 0] only, etc.. But OpenMDAO expects flattened indices for the rows and cols arguments, not multi-dimensional indices. So we need to convert the multi-dimensional indices in that table to flattened ones. get_rows_cols does that for you, but if you wanted to do that by hand, what I usually do is think of an array having the same shape as each input or output, with each entry in the array corresponding to the entry's flat index. So for x and y, that would be:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"x_flat_indices =\n[0 1 2;\n 3 4 5]\n\ny_flat_indices =\n[0 1 2;\n 3 4 5]","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"(Remember that Python/NumPy arrays use row-major aka C ordering by default.) So we can now use those two arrays to translate the y indices and x indices from multi-dimensional to flat:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"y indices     x indices\nmulti, flat:  multi, flat:\n(0, 0) 0      (0, 0) 0\n(0, 1) 1      (0, 1) 1\n(0, 2) 2      (0, 2) 2\n(1, 0) 3      (1, 0) 3\n(1, 1) 4      (1, 1) 4\n(1, 2) 5      (1, 2) 5","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"So the rows and cols arguments will be","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"rows = [0, 1, 2, 3, 4, 5]\ncols = [0, 1, 2, 3, 4, 5]","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"where rows is the flat non-zero indices for y, and cols is the flat non-zero indices for x.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, how do we do this with get_rows_cols? First we have to assign labels to each dimension of y and x. The labels must be Symbols, and can be anything (but I usually use index-y things like :i, :j, :k, etc.). We express the sparsity pattern through the choice of labels. If we use a label for an output dimension that is also used for an input dimension, then we are saying that, for a given index i in the \"shared\" dimension, the value of the output at that index i depends on the value of the input index i along the labeled dimension, and no others. For example, if we had a one-dimensional y that was calculated from a one-dimensional x in this way:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"for i in 1:10\n    y[i] = sin(x[i])\nend","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"then we would use the same label for the (single) output and input dimension.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"For the present example, we could assign i and j (say) to the first and second dimensions, respectively, of both y and x, since y[i,j] only depends on x[i,j] for all valid i and j. We call these of_ss (short for \"of subscripts for the output) and wrt_ss (\"with respect to subscripts\").","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"of_ss = [:i, :j]\nwrt_ss = [:i, :j]","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"After deciding on the dimension labels, the only other thing we need to do is create a Dict that maps the dimension labels to their sizes:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"ss_sizes = Dict(:i=>2, :j=>3)","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"since, in our example, the first dimension of x and y has size 2, and the second, 3.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Then we pass those three things to get_rows_cols, which then returns the rows and cols we want.","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"rows, cols = OpenMDAOCore.get_rows_cols(; ss_sizes, of_ss, wrt_ss)","category":"page"},{"location":"shape_by_conn/#Back-to-the-Simple-Example","page":"Variable Shapes at Runtime","title":"Back to the Simple Example","text":"","category":"section"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, back to the simple example. Remember, we're trying to compute y = 2*x^2 + 1 elementwise for a 2D x and y. The compute! method is pretty straight-forward:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"function OpenMDAOCore.compute!(self::ECompShapeByConn, inputs, outputs)\n    x = inputs[\"x\"]\n    y = outputs[\"y\"]\n    y .= 2 .* x.^2 .+ 1\n    return nothing\nend","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, for the compute_partials! method, we have to be a bit tricky about the shape of the Jacobian of y with respect to x. The get_rows_cols function orders the rows and cols in such a way that the Jacobian gets allocated by OpenMDAO with shape (i, j), and is then flattened. Since NumPy arrays are row-major ordered, then, we need to reshape the Jacobian in the opposite order, then switch the dimensions. This is optional, but makes things easier:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"function OpenMDAOCore.compute_partials!(self::ECompShapeByConn, inputs, partials)\n    x = inputs[\"x\"]\n    m, n = size(x)\n    # So, with the way I've declared the partials above, OpenMDAO will have\n    # created a Numpy array of shape (m, n) and then flattened it. So, to get\n    # that to work, I'll need to do this:\n    dydx = PermutedDimsArray(reshape(partials[\"y\", \"x\"], n, m), (2, 1))\n    dydx .= 4 .* x\n    return nothing\nend","category":"page"},{"location":"shape_by_conn/#Checking","page":"Variable Shapes at Runtime","title":"Checking","text":"","category":"section"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now, let's actually create a Problem with the new Component, along with an IndepVarComp that will actually decide on the size:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"using OpenMDAO, PythonCall\n\nm, n = 3, 4\np = om.Problem()\ncomp = om.IndepVarComp()\ncomp.add_output(\"x\", shape=(m, n))\np.model.add_subsystem(\"inputs_comp\", comp, promotes_outputs=[\"x\"])\n\necomp = ECompShapeByConn()\ncomp = make_component(ecomp)\np.model.add_subsystem(\"ecomp\", comp, promotes_inputs=[\"x\"], promotes_outputs=[\"y\"])\np.setup(force_alloc_complex=true)","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Now we should be able to check that the output we get is correct:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"p.set_val(\"x\", 1:m*n)\np.run_model()\n\n# Test that the output is what we expect.\nexpected = 2 .* PyArray(p.get_val(\"x\")).^2 .+ 1\nactual = PyArray(p.get_val(\"y\"))\nprintln(\"expected = $(expected)\")\nprintln(\"actual   = $(actual)\")","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"And we can check the derivatives:","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"p.check_partials(method=\"cs\")\nnothing","category":"page"},{"location":"shape_by_conn/","page":"Variable Shapes at Runtime","title":"Variable Shapes at Runtime","text":"Looks good!","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"brachistochrone/#A-Simple-Dymos-Example","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We can also use OpenMDAO.jl Components within a Dymos ODE. This example will implement the Brachistochrone example from the Dymos docs using Julia.","category":"page"},{"location":"brachistochrone/#Preamble","page":"A Simple Dymos Example","title":"Preamble","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"Let's make things easier on ourselves and import the VarData and PartialsData names into our local namespace:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using OpenMDAOCore: OpenMDAOCore, VarData, PartialsData","category":"page"},{"location":"brachistochrone/#The-AbstractExplicitComp-struct","page":"A Simple Dymos Example","title":"The AbstractExplicitComp struct","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The ODE component for the brachistochrone has two options:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"num_nodes, the number of nodes used to descritize the trajectory of the bead.\nstatic_gravity, a flag to indicate whether gravity should vary along the trajectory (and thus have length num_nodes) or if it should be constant (and thus be a scalar).","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We'll use a default value of false for static_gravity, just like the Python implementation in the Dymos docs:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"struct BrachistochroneODE <: OpenMDAOCore.AbstractExplicitComp\n    num_nodes::Int\n    static_gravity::Bool\nend\n\n# `static_gravity` set to `false` by default.\nBrachistochroneODE(; num_nodes, static_gravity=false) = BrachistochroneODE(num_nodes, static_gravity)","category":"page"},{"location":"brachistochrone/#OpenMDAOCore.setup","page":"A Simple Dymos Example","title":"OpenMDAOCore.setup","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"Next we'll define the OpenMDAOCore.setup function:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.setup(self::BrachistochroneODE)\n\tnn = self.num_nodes\n\n\t# Inputs\n    input_data = Vector{VarData}()\n    push!(input_data, VarData(\"v\"; val=zeros(nn), units=\"m/s\"))\n\tif self.static_gravity\n        push!(input_data, VarData(\"g\", val=9.80665, units=\"m/s/s\", tags=[\"dymos.static_target\"]))\n\telse\n        push!(input_data, VarData(\"g\", val=9.80665 * ones(nn), units=\"m/s/s\"))\n    end\n    push!(input_data, VarData(\"theta\", val=ones(nn), units=\"rad\"))\n\n    # Outputs\n    output_data = Vector{VarData}()\n    push!(output_data, VarData(\"xdot\", val=zeros(nn), units=\"m/s\", tags=[\"dymos.state_rate_source:x\", \"dymos.state_units:m\"]))\n    push!(output_data, VarData(\"ydot\", val=zeros(nn), units=\"m/s\", tags=[\"dymos.state_rate_source:y\", \"dymos.state_units:m\"]))\n    push!(output_data, VarData(\"vdot\", val=zeros(nn), units=\"m/s**2\", tags=[\"dymos.state_rate_source:v\", \"dymos.state_units:m/s\"]))\n    push!(output_data, VarData(\"check\", val=zeros(nn), units=\"m/s\"))\n\n    # Setup partials\n    arange = 0:nn-1\n    partials_data = Vector{PartialsData}()\n    push!(partials_data, PartialsData(\"vdot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"xdot\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"xdot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"ydot\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"ydot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"check\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"check\", \"theta\"; rows=arange, cols=arange))\n\n\tif self.static_gravity\n\t\tc = zeros(Int, self.num_nodes)\n        push!(partials_data, PartialsData(\"vdot\", \"g\"; rows=arange, cols=c))\n\telse\n        push!(partials_data, PartialsData(\"vdot\", \"g\"; rows=arange, cols=arange))\n    end\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"This is probably the most complicated setup we've seen yet. A few things to note:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We can change the size of the g (gravity) input and its sub-Jacobian using the static_gravity option in the BrachistochroneODE struct.\nThe VarData calls use tags, which are passed to the ExplicitComponent.add_input method using the tags keyword argument in OpenMDAO.\nAs we'll see, the job of a Dymos ODE is to compute the state rates from the states and controls. It turns out that in many (all) ODEs, these state rates for a given trajectory node only depend on the state and controls at that particular node. This implies that the Jacobian of the ODE calculation will be sparse. This example, like the original Python implementation, passes the sparsity pattern of the various sub-Jacobians to the PartialsData structs using the rows and cols keywords.","category":"page"},{"location":"brachistochrone/#OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!","page":"A Simple Dymos Example","title":"OpenMDAOCore.compute! and OpenMDAOCore.compute_partials!","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The OpenMDAOCore.compute! method for our ODE is fairly straightforward:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.compute!(self::BrachistochroneODE, inputs, outputs)\n\ttheta = inputs[\"theta\"]\n\tcos_theta = cos.(theta)\n\tsin_theta = sin.(theta)\n\tg = inputs[\"g\"]\n\tv = inputs[\"v\"]\n\n\t@. outputs[\"vdot\"] = g * cos_theta\n\t@. outputs[\"xdot\"] = v * sin_theta\n\t@. outputs[\"ydot\"] = -v * cos_theta\n\t@. outputs[\"check\"] = v / sin_theta\n\n    return nothing\nend","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The @. macro tells Julia to use broadcasting for the array calculations (similar to NumPy broadcasting).","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The compute_partials! method is also quite similar to the original Python implementation:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.compute_partials!(self::BrachistochroneODE, inputs, partials)\n\ttheta = inputs[\"theta\"]\n\tcos_theta = cos.(theta)\n\tsin_theta = sin.(theta)\n\tg = inputs[\"g\"]\n\tv = inputs[\"v\"]\n\n\t@. partials[\"vdot\", \"g\"] = cos_theta\n\t@. partials[\"vdot\", \"theta\"] = -g * sin_theta\n\n\t@. partials[\"xdot\", \"v\"] = sin_theta\n\t@. partials[\"xdot\", \"theta\"] = v * cos_theta\n\n\t@. partials[\"ydot\", \"v\"] = -cos_theta\n\t@. partials[\"ydot\", \"theta\"] = v * sin_theta\n\n\t@. partials[\"check\", \"v\"] = 1 / sin_theta\n\t@. partials[\"check\", \"theta\"] = -v * cos_theta / sin_theta ^ 2\n\n\treturn nothing\nend","category":"page"},{"location":"brachistochrone/#The-run-script","page":"A Simple Dymos Example","title":"The run script","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We'll need the Dymos library to solve the Brachistochrone problem, of course:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using PythonCall: pyimport\ndm = pyimport(\"dymos\")","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"And then the rest of the script will be pretty much identical to the Python version, but written in Julia. We'll put it in a function that allows us to try out static_gravity=false and static_gravity=true.","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using OpenMDAO: om, make_component, DymosifiedCompWrapper\n\nfunction main(; static_gravity)\n  #\n  # Initialize the Problem and the optimization driver\n  #\n  p = om.Problem(model=om.Group())\n  p.driver = om.ScipyOptimizeDriver()\n  p.driver.declare_coloring()\n  #\n  # Create a trajectory and add a phase to it\n  #\n  traj = p.model.add_subsystem(\"traj\", dm.Trajectory())\n\n  # `Trajectory.add_phase` expects a class that it can instantiate with the number of nodes used for the phase.\n  # That's easy enough to create with an anonymous function, but unfortunatly it won't work with Dymos (because of the way JuliaCall implements truthiness/falsiness of Julia callables).\n  # So, as a workaround, OpenMDAO.jl has a small wrapper `struct` that will fix this for us called `DymosifiedCompWrapper`.\n  # The way this works: we give DymosifiedCompWrapper the ODE type (not a type instance, the type itself), and the keyword arguments we need to instantiate the type, other than `num_nodes`.\n  # Check out the docstring for an example.\n  dcw = DymosifiedCompWrapper(BrachistochroneODE; static_gravity=static_gravity)\n  phase = traj.add_phase(\"phase0\",\n                         dm.Phase(ode_class = dcw,\n                                  transcription = dm.GaussLobatto(num_segments=10)))\n\n  #\n  # Set the variables\n  #\n  phase.set_time_options(fix_initial=true, duration_bounds=(.5, 10))\n\n  phase.add_state(\"x\", fix_initial=true, fix_final=true)\n\n  phase.add_state(\"y\", fix_initial=true, fix_final=true)\n\n  phase.add_state(\"v\", fix_initial=true, fix_final=false)\n\n  phase.add_control(\"theta\", continuity=true, rate_continuity=true,\n                    units=\"deg\", lower=0.01, upper=179.9)\n\n  phase.add_parameter(\"g\", units=\"m/s**2\", val=9.80665)\n\n  #\n  # Minimize time at the end of the phase\n  #\n  phase.add_objective(\"time\", loc=\"final\", scaler=10)\n  # \n  p.model.linear_solver = om.DirectSolver()\n  #\n  # Setup the Problem\n  #\n  p.setup()\n\n  #\n  # Set the initial values\n  #\n  p[\"traj.phase0.t_initial\"] = 0.0\n  p[\"traj.phase0.t_duration\"] = 2.0\n\n  p.set_val(\"traj.phase0.states:x\", phase.interp(\"x\", ys=[0, 10]))\n  p.set_val(\"traj.phase0.states:y\", phase.interp(\"y\", ys=[10, 5]))\n  p.set_val(\"traj.phase0.states:v\", phase.interp(\"v\", ys=[0, 9.9]))\n  p.set_val(\"traj.phase0.controls:theta\", phase.interp(\"theta\", ys=[5, 100.5]))\n\n  #\n  # Solve for the optimal trajectory\n  #\n  dm.run_problem(p)\n\n  # Check the results\n  println(\"static_gravity = $static_gravity, elapsed time = $(p.get_val(\"traj.phase0.timeseries.time\")[-1]) (should be 1.80164719)\")\nend\n\nmain(; static_gravity=false)\nmain(; static_gravity=true)","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"At the end we see we got pretty much the same answer for the elapsed time as the Python example in the Dymos docs. (But not exactly the same, which is a bummer...)","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"limitations/#Limitations","page":"Limitations","title":"Limitations","text":"","category":"section"},{"location":"limitations/#Import-juliacall-first-from-Python...-sometimes","page":"Limitations","title":"Import juliacall first from Python... sometimes","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"When using the omjlcomps Python library, it is sometimes necessary to import juliacall before other Python libraries (at least matplotlib, maybe others too) to avoid an error that looks like this:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"$ cat test.py\nimport matplotlib\nimport juliacall\n$ python test.py\nERROR: `ccall` requires the compilerTraceback (most recent call last):\n  File \"/home/dingraha/desk/pythoncall_wtf/test.py\", line 2, in <module>\n    import juliacall\n  File \"/home/dingraha/desk/pythoncall_wtf/venv-mybuild-with-libc-enable-shared-without-lto-without-optimizations-computed-gotos-no-dtrace-no-ssl/lib/python3.9/site-packages/juliacall/__init__.py\", line 218, in <module>\n    init()\n  File \"/home/dingraha/desk/pythoncall_wtf/venv-mybuild-with-libc-enable-shared-without-lto-without-optimizations-computed-gotos-no-dtrace-no-ssl/lib/python3.9/site-packages/juliacall/__init__.py\", line 214, in init\n    raise Exception('PythonCall.jl did not start properly')\nException: PythonCall.jl did not start properly\n$","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"This only occurs when using the system Python on certain Linux distributions (e.g., Python 3.9.7 on Red Hat Enterprise Linux 8.6). I've found three workarounds:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"import the juliacall module first in your run script, before anything else, or\ndon't use the system Python: set up a Conda environment instead, or\ndon't use RHEL (the system Python on e.g. Arch Linux doesn't appear to suffer from this bug).","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"See this PythonCall issue for a few more details.","category":"page"},{"location":"limitations/#Dymos-ODEs-and-the-truthiness-of-Julia-callables-in-Python","page":"Limitations","title":"Dymos ODEs and the truthiness of Julia callables in Python","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"To create a Dymos phase, the Dymos library requires the user to pass either a function or OpenMDAO System subclass that takes a num_nodes argument and return an OpenMDAO System that implements the ODE associated with the Dymos Phase. How do we do that with OpenMDAO.jl? It's easy enough to create, say, an AbstractExplicitComp that takes a num_nodes argument:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"using OpenMDAOCore: OpenMDAOCore\nstruct FooODE <: OpenMDAOCore.AbstractExplicitComp\n    num_nodes::Int\n    # made-up options:\n    a::Float64\n    b::Bool\nend","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"and then use make_component and a function to create a callable Julia function that fulfills Dymos' requirements:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"using OpenMDAO: om, make_component\na = 8.0\nb = true\nmake_ode(num_nodes) = make_component(FooODE(num_nodes, a, b))\nprintln(\"make_ode = $(make_ode), typeof(make_ode) = $(typeof(make_ode))\")","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"But can we use that to construct a Dymos Phase?","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"using PythonCall: pyimport\ndm = pyimport(\"dymos\")\n#\n# Initialize the Problem and the optimization driver\n#\np = om.Problem(model=om.Group())\np.driver = om.ScipyOptimizeDriver()\np.driver.declare_coloring()\n#\n# Create a trajectory and add a phase to it\n#\ntraj = p.model.add_subsystem(\"traj\", dm.Trajectory())\nphase = traj.add_phase(\"phase0\",\n                       dm.Phase(ode_class = make_ode,\n                                transcription = dm.GaussLobatto(num_segments=10)))","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"Yes! So we should be able to it in a trajectory optimization, right?","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"#\n# Set the variables\n#\nphase.set_time_options(fix_initial=true, duration_bounds=(.5, 10))\n\nphase.add_state(\"x\", fix_initial=true, fix_final=true)\n\nphase.add_state(\"y\", fix_initial=true, fix_final=true)\n\nphase.add_state(\"v\", fix_initial=true, fix_final=false)\n\nphase.add_control(\"theta\", continuity=true, rate_continuity=true,\n                  units=\"deg\", lower=0.01, upper=179.9)\n\nphase.add_parameter(\"g\", units=\"m/s**2\", val=9.80665)\n\n#\n# Minimize time at the end of the phase\n#\nphase.add_objective(\"time\", loc=\"final\", scaler=10)\n# \np.model.linear_solver = om.DirectSolver()\n#\n# Setup the Problem\n#\n# p.setup() # Commented out to avoid error.\n# This will throw something like:\n#\n# │   value =\n# │    Python: TypeError: Julia: MethodError: no method matching length(::typeof(Main.__atexample__named__dymos_callable.make_ode))\n# │    Closest candidates are:\n# │      length(!Matched::Union{Base.KeySet, Base.ValueIterator}) at abstractdict.jl:58\n# │      length(!Matched::Union{LinearAlgebra.Adjoint{T, S}, LinearAlgebra.Transpose{T, S}} where {T, S}) at ~/local/julia/1.8.5/share/julia/stdlib/v1.8/LinearAlgebra/src/adjtrans.jl:172\n# │      length(!Matched::Union{Tables.AbstractColumns, Tables.AbstractRow}) at ~/.julia/packages/Tables/T7rHm/src/Tables.jl:180\n# │      ...","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"Nope, sad: the Problem.setup() call on the last line of that example throws an error. What's going wrong? I am not 100% clear on all the details, but what I think is happening is this:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"During the Phase.setup method, Dymos checks for the truthiness of the ode_class Phase option.\nWhat is the truthiness of a class in Python? It depends:\nIf the __bool__ method is defined for the class, that result of calling that is used,\nIf __bool__ isn't defined, then if __len__ is defined, the result of calling that is used, with 0 considered False and any other value True,\nIf neither __bool__ nor __len__ are defined, then the class is considered True.\nThe Julia function make_ode that we pass to the Phase constructor is converted to an AnyValue on the Python side by the Julia package PythonCall. The AnyValue class doesn't implement __bool__, but it does implement __len__, which calls the Julia function length on the Julia object.\nBut length doesn't have a method for plain old Julia functions, hence the error above.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"The workaround is to create a small struct called DymosifiedCompWrapper that takes an OpenMDAOCore.AbstractComp type (not instance) and all the non-num_nodes arguments, and implement a Base.length method for DymosifiedCompWrapper that always returns 1, a truthy value in Python.","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"See the PythonCall issue on this topic for news related to this topic.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [OpenMDAOCore, OpenMDAO]","category":"page"},{"location":"reference/#OpenMDAOCore.PartialsData","page":"API Reference","title":"OpenMDAOCore.PartialsData","text":"PartialsData(of::String, wrt::String; <keyword arguments>)\n\nCreate a PartialsData object for the derivative of variable of with respect to variable wrt.\n\nPartialsData objects are used to construct arguments to OpenMDAO's Component.declare_partials method. Specifically, a PartialsData object pd will eventually be used to call Component.declare_partials like this:\n\nComponent.declare_partials(pd.of, pd.wrt, rows=pd.rows, cols=pd.cols, val=pd.val, method=pd.method)\n\nThe of and wrt positional arguments are required and set the of and wrt fields. The value of the other PartialsData fields (e.g., pd.rows, pd.val, etc.) are set via constructor keyword arguments, here:\n\nKeyword Arguments\n\nrows::Union{<:AbstractVector{Int64},Nothing} = nothing: row indices for each non-zero Jacobian entry, if not nothing.\ncols::Union{<:AbstractVector{Int64},Nothing} = nothing: column indices for each non-zero Jacobian entry, if not nothing.\nval::Union{Float64,<:AbstractArray{Float64},Nothing} = nothing: value of Jacobian, if not nothing.\nmethod::String = \"exact\": method use to calcluate the partial derivative(s). Should be one of\n\"exact\": user-defined partial derivatives via compute_partials!, linearize!, etc.\n\"fd\": finite difference approximation\n\"cs\": complex step approximation\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAOCore.VarData","page":"API Reference","title":"OpenMDAOCore.VarData","text":"VarData(name::String; <keyword arguments>)\n\nCreate a VarData object for an OpenMDAO variable named name.\n\nVarData objects are used to construct arguments to OpenMDAO's Component.add_input and Component.add_output methods. Specifically, if a VarData object var refers to an input variable, the Component.add_input call will look like this:\n\nComponent.add_input(var.name, shape=var.shape, val=var.val, units=var.units, tags=var.tags, shape_by_conn=var.shape_by_conn)\n\nand if the VarData object var is an output variable, the Component.add_output call will look like this:\n\nComponent.add_output(var.name, shape=var.shape, val=var.val, units=var.units, lower=var.lower, upper=var.upper, tags=var.tags, shape_by_conn=var.shape_by_conn)\n\nThe name positional argument is required and sets the name field. The value of the other VarData fields (e.g., var.shape, var.val, etc.) are set via constructor keyword arguments, here:\n\nKeyword Arguments\n\nval::Union{Float64,<:AbstractArray{Float64},Nothing} = 1.0: variable's default value, set to 1.0 if nothing.\nshape::Union{Int64,NTuple{N,Int64},Nothing} = (1,): variable shape, set to (1,) if nothing.\nunits::Union{String,Nothing} = nothing: variable units.\nlower::Union{Float64,<:AbstractArray{Float64,N},Nothing} = nothing: variable's lower limit.\nupper::Union{Float64,<:AbstractArray{Float64,N},Nothing} = nothing: variable's upper limit.\ntags::Union{<:AbstractVector{String},Nothing} = nothing: variable tags.\nshape_by_conn::Bool = false: if true, shape this variable by its connected output (if an input) or input (if an output)\ncopy_shape::Union{String,Nothing} = nothing: if a string, shape this variable by the local variable indicated by copy_shape\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAOCore.get_rows_cols-Tuple{}","page":"API Reference","title":"OpenMDAOCore.get_rows_cols","text":"get_rows_cols(; ss_sizes::Dict{Symbol, Int}, of_ss::AbstractVector{Symbol}, wrt_ss::AbstractVector{Symbol})\n\nGet the non-zero row and column indices for a sparsity pattern defined by output subscripts of_ss and input subscripts wrt_ss.\n\nss_sizes is a Dict mapping the subscript symbols in of_ss and wrt_ss to the size of each dimension the subscript symbols correspond to. The returned indices will be zero-based, which is what the OpenMDAO declare_partials method expects.\n\nExamples\n\nDiagonal partials for 1D output and 1D input, both with length 5:\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>5), of_ss=[:i], wrt_ss=[:i])\n([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])\n\n1D output with length 2 depending on all elements of 1D input with length 3 (so not actually sparse).\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>2, :j=>3), of_ss=[:i], wrt_ss=[:j])\n([0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2])\n\n2D output with size (2, 3) and 1D input with size 2, where each i output row only depends on the i input element.\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>2, :j=>3), of_ss=[:i, :j], wrt_ss=[:i])\n([0, 1, 2, 3, 4, 5], [0, 0, 0, 1, 1, 1])\n\n2D output with size (2, 3) and 1D input with size 3, where each j output column only depends on the j input element.\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>2, :j=>3), of_ss=[:i, :j], wrt_ss=[:j])\n([0, 1, 2, 3, 4, 5], [0, 1, 2, 0, 1, 2])\n\n2D output with size (2, 3) depending on input with size (3, 2), where the output element at index i, j only depends on input element j, i (like a transpose operation).\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>2, :j=>3), of_ss=[:i, :j], wrt_ss=[:j, :i])\n([0, 1, 2, 3, 4, 5], [0, 2, 4, 1, 3, 5])\n\n2D output with size (2, 3) depending on input with size (3, 4), where output y[:, j] for each j depends on input x[j, :].\n\njulia> rows, cols = get_rows_cols(; ss_sizes=Dict(:i=>2, :j=>3, :k=>4), of_ss=[:i, :j], wrt_ss=[:j, :k]);\n\njulia> @show rows cols;  # to prevent abbreviating the array display\nrows = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]\ncols = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenMDAO.DymosifiedCompWrapper","page":"API Reference","title":"OpenMDAO.DymosifiedCompWrapper","text":"DymosifiedCompWrapper{Tkwargs}\n\nWrapper type that stores a type (not an instance) of an <:OpenMDAOCore.AbstractComp and the non-num_nodes keyword arguments (if any) used to construct the instance.\n\nExample\n\njulia> using OpenMDAOCore: OpenMDAOCore\n\njulia> using OpenMDAO\n\njulia> struct FooODE <: OpenMDAOCore.AbstractExplicitComp\n         num_nodes::Int\n         a::Float64\n       end\n\njulia> FooODE(; num_nodes, a) = FooODE(num_nodes, a)\nFooODE\n\njulia> dcw = OpenMDAO.DymosifiedCompWrapper(FooODE; a=8.0)\nOpenMDAO.DymosifiedCompWrapper{Base.Pairs{Symbol, Float64, Tuple{Symbol}, NamedTuple{(:a,), Tuple{Float64}}}}(FooODE, Base.Pairs(:a => 8.0))\n\njulia> comp = dcw(num_nodes=4)\nPython JuliaExplicitComp: <omjlcomps.JuliaExplicitComp object at 0x7f38429333a0>\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAO.DymosifiedCompWrapper-Tuple{Any}","page":"API Reference","title":"OpenMDAO.DymosifiedCompWrapper","text":"DymosifiedCompWrapper(TComp::Type{<:OpenMDAOCore.AbstractComp}; kwargs...)\n\nConstruct a wrapper to a <:OpenMDAOCore.AbstractComp that can be used to create a omjlcomps.JuliaExplicitComp or omjlcomps.JuliaImplicitComp by just passing a num_nodes argument.\n\nArguments\n\nTComp: An OpenMDAOCore.AbstractComp type, not an instance (so TComp = FooComp, not TComp = FooComp(), analogous to the difference between Float64 and 1.0),\nkwargs: keyword arguments, other than num_nodes, that are needed to construct an instance of TComp\n\nExample\n\njulia> using OpenMDAOCore: OpenMDAOCore\n\njulia> using OpenMDAO\n\njulia> struct FooODE <: OpenMDAOCore.AbstractExplicitComp\n         num_nodes::Int\n         a::Float64\n       end\n\njulia> FooODE(; num_nodes, a) = FooODE(num_nodes, a)\nFooODE\n\njulia> dcw = OpenMDAO.DymosifiedCompWrapper(FooODE; a=8.0)\nOpenMDAO.DymosifiedCompWrapper{Base.Pairs{Symbol, Float64, Tuple{Symbol}, NamedTuple{(:a,), Tuple{Float64}}}}(FooODE, Base.Pairs(:a => 8.0))\n\njulia> comp = dcw(num_nodes=4)\nPython JuliaExplicitComp: <omjlcomps.JuliaExplicitComp object at 0x7f38429333a0>\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenMDAO.make_component","page":"API Reference","title":"OpenMDAO.make_component","text":"make_component(comp::OpenMDAOCore.AbstractComp)\n\nConvinience method for creating either a JuliaExplicitComp or JuliaImplicitComp, depending on if comp is <:OpenMDAOCore.AbstractExplicitComp or <:OpenMDAOCore.AbstractImplicitComp, respectively.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"#OpenMDAO.jl-Documentation","page":"Home","title":"OpenMDAO.jl Documentation","text":"","category":"section"},{"location":"#What?","page":"Home","title":"What?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use Julia with OpenMDAO! OpenMDAO.jl is a Julia package that allows a user to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Write OpenMDAO Components in Julia, and incorporate these components into a OpenMDAO model.\nCreate and run optimizations in Julia, using OpenMDAO as a library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenMDAO.jl consists of three pieces of software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenMDAOCore.jl: A small, pure-Julia package that allows users to define Julia code that will eventually be used in an OpenMDAO Problem. OpenMDAOCore.jl defines two Julia abstract types (AbstractExplicitComponent and AbstractImplicitComponent) and methods that mimic OpenMDAO's ExplicitComponent and ImplicitComponent classes.\nomjlcomps: A Python package (actually, a OpenMDAO Plugin) that defines two classes, JuliaExplicitComp and JuliaImplicitComp, which inherit from OpenMDAO's ExplicitComponent and ImplicitComponent, respectively. These components take instances of concrete subtypes of OpenMDAOCore.ExplicitComponent and OpenMDAOCore.ImplicitComponent and turn them into instances of JuliaExplicitComp and JuliaImplicitComp. Like any other OpenMDAO ExplicitComponent or ImplicitComponent objects, JuliaExplicitComp and JuliaImplicitComp instances can be used in an OpenMDAO model, but call Julia code in their methods (compute, apply_nonlinear, etc.).\nOpenMDAO.jl: A Julia package that has the openmdao and omjlcomps Python packages as dependencies. Users can install OpenMDAO.jl and have the full power of the OpenMDAO framework at their disposal in Julia.","category":"page"},{"location":"#How-(Installation-Instructions)?","page":"Home","title":"How (Installation Instructions)?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two approaches to getting OpenMDAO working with Julia: the Python-Centric Approach and the Julia-Centric Approach. If you like Python and just want to have a little (or a lot) of Julia buried in your OpenMDAO System, then you'll probably prefer the Python-centric approach. If you're a huge fan of Julia and would like to pretend that OpenMDAO is a Julia library, you'll want the Julia-centric approach. Either way, pick one or the other: you don't need to follow both installation instructions.","category":"page"},{"location":"#python_centric","page":"Home","title":"Python-Centric Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first (and only!) step is to install omjlcomps, which is in the Python Package Index, so a simple","category":"page"},{"location":"","page":"Home","title":"Home","text":"pip install omjlcomps","category":"page"},{"location":"","page":"Home","title":"Home","text":"should be all you need. omjlcomps uses JuliaPkg to manage Julia dependencies, so all the Julia packages needed by omjlcomps (and even Julia itself, if necessary) will be installed automatically.","category":"page"},{"location":"#julia_centric","page":"Home","title":"Julia-Centric Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The OpenMDAOCore.jl and OpenMDAO.jl Julia packages are registered in the General registry, so installation should be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add OpenMDAOCore OpenMDAO","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the Julia REPL. OpenMDAOCore.jl is a fairly small package without any Python dependencies, but OpenMDAO.jl depends on omjlcomps and openmdao itself. OpenMDAO.jl's Python dependencies are managed by CondaPkg, and should be automatically installed into a separate Conda environment specific to your current Julia environment.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An early version of OpenMDAO.jl was written by Daniel Ingraham, Justin Gray, and Andrew Ning while visiting Prof. Ning at Brigham Young University.\nOpenMDAO.jl depends heavily on PythonCall and related packages, developed by Christopher Rowley.","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"nonlinear_circuit/#A-More-Complicated-Example:-Nonlinear-Circuit","page":"A More Complicated Example","title":"A More Complicated Example: Nonlinear Circuit","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"This tutorial will implement the nonlinear circuit example from the OpenMDAO docs in Julia. Along the way, we'll learn","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"how to create implicit components with OpenMDAO.jl\nhow to create OpenMDAO.jl components with metadata (the equivalent of options in a normal Python component)\nhow to specify default values for component metadata","category":"page"},{"location":"nonlinear_circuit/#Preamble","page":"A More Complicated Example","title":"Preamble","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We'll need the OpenMDAOCore package, of course:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"using OpenMDAOCore: OpenMDAOCore","category":"page"},{"location":"nonlinear_circuit/#An-Explicit-Component-with-an-Option:-The-Resistor","page":"A More Complicated Example","title":"An Explicit Component with an Option: The Resistor","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next we'll create an explicit component that models a resistor. The resistor has one option: the resistance, R. We'll make R a field in the Julia struct that we'll use for the Resistor component:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Resistor <: OpenMDAOCore.AbstractExplicitComp\n    R::Float64\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Now we'd like to use a default value of 1.0 for the resistance. We can do that by creating an outer constructor for the Resistor struct with a default keyword value.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"# Default value for R.\nResistor(; R=1.0) = Resistor(R)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll create a setup function as usual:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Resistor)\n    input_data = [OpenMDAOCore.VarData(\"V_in\"; units=\"V\"), OpenMDAOCore.VarData(\"V_out\"; units=\"V\")]\n    output_data = [OpenMDAOCore.VarData(\"I\"; units=\"A\")]\n\n    R = self.R\n    partials_data = [OpenMDAOCore.PartialsData(\"I\", \"V_in\", val=1/R),\n                     OpenMDAOCore.PartialsData(\"I\", \"V_out\", val=-1/R),]\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Since this is a linear resistor, the derivatives are constant, and we can set them via the val argument in the PartialsData struct, just like in OpenMDAO's declare_partials method. Also notice that we can specify units for each of the inputs and outputs, just like in a Python OpenMDAO component.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, we'll implement the compute! method:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.compute!(self::Resistor, inputs, outputs)\n    deltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n    outputs[\"I\"][1] = deltaV/self.R\n\n    return nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Notice that we have access to the R field in the Resistor struct, named self here. (We could call it anything, just like in a Python method.)","category":"page"},{"location":"nonlinear_circuit/#An-Explicit-Component-with-Two-Options:-The-Diode","page":"A More Complicated Example","title":"An Explicit Component with Two Options: The Diode","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We need two parameters to characterize the Diode: the saturation current Is and the thermal voltage Vt:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Diode <: OpenMDAOCore.AbstractExplicitComp\n    Is::Float64\n    Vt::Float64\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll create an constructor that sets both options using keyword arguments, and provides default values for both.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"# Use Julia's keyword arguments to set default values.\nDiode(; Is=1e-15, Vt=0.025875) = Diode(Is, Vt)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next, we'll implement the setup method for the Diode.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Diode)\n    input_data = [OpenMDAOCore.VarData(\"V_in\"; units=\"V\"), OpenMDAOCore.VarData(\"V_out\"; units=\"V\")]\n    output_data = [OpenMDAOCore.VarData(\"I\"; units=\"A\")]\n\n    partials_data = [OpenMDAOCore.PartialsData(\"I\", \"V_in\"), OpenMDAOCore.PartialsData(\"I\", \"V_out\")]\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Nothing unusual here.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, the compute! and compute_partials! methods:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.compute!(self::Diode, inputs, outputs)\n    deltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n\tIs = self.Is\n\tVt = self.Vt\n    outputs[\"I\"][1] = Is * (exp(deltaV / Vt) - 1)\n    return nothing\nend\n\nfunction OpenMDAOCore.compute_partials!(self::Diode, inputs, J)\n\tdeltaV = inputs[\"V_in\"][1] - inputs[\"V_out\"][1]\n\tIs = self.Is\n\tVt = self.Vt\n\tI = Is * exp(deltaV / Vt)\n\n\tJ[\"I\", \"V_in\"][1, 1] = I/Vt\n\tJ[\"I\", \"V_out\"][1, 1] = -I/Vt\n\n\treturn nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Like the Resistor, we have access to the Is and Vt options in the Diode struct in both methods.","category":"page"},{"location":"nonlinear_circuit/#Our-First-Implicit-Component:-The-Node","page":"A More Complicated Example","title":"Our First Implicit Component: The Node","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Our final component we need for the circuit is an implicit one: the Node. Each node can have an arbitrary number of incoming and outgoing currents, so we'll need two integer options to keep track of that:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"struct Node <: OpenMDAOCore.AbstractImplicitComp\n    n_in::Int\n\tn_out::Int\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We'll have n_in and n_out both default to one, though:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Node(; n_in=1, n_out=1) = Node(n_in, n_out)","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Next up is the setup method. We'll need to use a loop to create all the inputs and outputs needed for the component:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.setup(self::Node)\n    output_data = [OpenMDAOCore.VarData(\"V\", val=5.0, units=\"V\")]\n\n    input_data = Vector{OpenMDAOCore.VarData}()\n    partials_data = Vector{OpenMDAOCore.PartialsData}()\n\n\tfor i in 0:self.n_in-1\n        i_name = \"I_in:$i\"\n        push!(input_data, OpenMDAOCore.VarData(i_name; units=\"A\"))\n        push!(partials_data, OpenMDAOCore.PartialsData(\"V\", i_name; val=1.0))\n\tend\n\n\tfor i in 0:self.n_out-1\n        i_name = \"I_out:$i\"\n        push!(input_data, OpenMDAOCore.VarData(i_name; units=\"A\"))\n        push!(partials_data, OpenMDAOCore.PartialsData(\"V\", i_name; val=-1.0))\n\tend\n\n\treturn input_data, output_data, partials_data\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We could have done something fancier like an array comprehension to create the VarData and PartialsData structs:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"input_data = [OpenMDAOCore.VarData(\"I_in:$i\"; units=\"A\") for i in 0:self.n_in-1]","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Also, the derivatives are constant for the node, so we set them in the PartialsData struct.","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Finally, we just need to write the apply_nonlinear! method:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"function OpenMDAOCore.apply_nonlinear!(self::Node, inputs, outputs, residuals)\n    residuals[\"V\"][1] = 0.0\n    for i_conn in 0:self.n_in-1\n        residuals[\"V\"][1] += inputs[\"I_in:$i_conn\"][1]\n    end\n    for i_conn in 0:self.n_out-1\n        residuals[\"V\"][1] -= inputs[\"I_out:$i_conn\"][1]\n    end\n\n    return nothing\nend","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We see that the apply_nonlinear! OpenMDAO.jl method is very similar to the apply_nonlinear method on a normal Python ImplicitComponent— its job is to calculate the residual of the implicit equation(s) it is modeling from the inputs and outputs.","category":"page"},{"location":"nonlinear_circuit/#The-Run-Script","page":"A More Complicated Example","title":"The Run Script","text":"","category":"section"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We're finally ready for the run script! Here it is:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"using OpenMDAO: om, make_component\n\np = om.Problem()\n\ncircuit = om.Group()\n\ncircuit.add_subsystem(\"n1\", make_component(Node(n_in=1, n_out=2)), promotes_inputs=[(\"I_in:0\", \"I_in\")])\ncircuit.add_subsystem(\"n2\", make_component(Node()))\n\ncircuit.add_subsystem(\"R1\", make_component(Resistor(R=100.0)), promotes_inputs=[(\"V_out\", \"Vg\")])\ncircuit.add_subsystem(\"R2\", make_component(Resistor(R=10000.0)))\ncircuit.add_subsystem(\"D1\", make_component(Diode()), promotes_inputs=[(\"V_out\", \"Vg\")])\n\ncircuit.connect(\"n1.V\", [\"R1.V_in\", \"R2.V_in\"])\ncircuit.connect(\"R1.I\", \"n1.I_out:0\")\ncircuit.connect(\"R2.I\", \"n1.I_out:1\")\n\ncircuit.connect(\"n2.V\", [\"R2.V_out\", \"D1.V_in\"])\ncircuit.connect(\"R2.I\", \"n2.I_in:0\")\ncircuit.connect(\"D1.I\", \"n2.I_out:0\")\n\ncircuit.nonlinear_solver = om.NewtonSolver()\ncircuit.linear_solver = om.DirectSolver()\n\ncircuit.nonlinear_solver.options[\"iprint\"] = 2\ncircuit.nonlinear_solver.options[\"maxiter\"] = 10\ncircuit.nonlinear_solver.options[\"solve_subsystems\"] = true\ncircuit.nonlinear_solver.linesearch = om.ArmijoGoldsteinLS()\ncircuit.nonlinear_solver.linesearch.options[\"maxiter\"] = 10\ncircuit.nonlinear_solver.linesearch.options[\"iprint\"] = 2\n\np.model.add_subsystem(\"circuit\", circuit)\n\np.setup()\n\np.set_val(\"circuit.I_in\", 0.1)\np.set_val(\"circuit.Vg\", 0.)\n\n# set some initial guesses\np.set_val(\"circuit.n1.V\", 10.)\np.set_val(\"circuit.n2.V\", 1e-3)\n\np.run_model()\n\nprintln(\"circuit.n1.V = $(p[\"circuit.n1.V\"]) (should be 9.90804735)\")\nprintln(\"circuit.n2.V = $(p[\"circuit.n2.V\"]) (should be 0.71278185)\")\nprintln(\"circuit.R1.I = $(p[\"circuit.R1.I\"]) (should be 0.09908047)\")\nprintln(\"circuit.R2.I = $(p[\"circuit.R2.I\"]) (should be 0.00091953)\")\nprintln(\"circuit.D1.I = $(p[\"circuit.D1.I\"]) (should be 0.00091953)\")\n\n# sanity check: should sum to .1 Amps\nprintln(\"circuit.R1.I + circuit.D1.I = $(p[\"circuit.R1.I\"] + p[\"circuit.D1.I\"]) (should be 0.1)\")","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"Notice that:","category":"page"},{"location":"nonlinear_circuit/","page":"A More Complicated Example","title":"A More Complicated Example","text":"We can use Groups and connect methods just like a Python OpenMDAO program\nLinear and nonlinear solvers, and linesearch objects also work fine\nWe get the same answers as the Python example in the OpenMDAO docs! :-)","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"simple_paraboloid/#A-Simple-Example:-Optimizing-a-Paraboloid","page":"A Simple Example","title":"A Simple Example: Optimizing a Paraboloid","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We're going to duplicate the Paraboloid example from the OpenMDAO documentation, but implement the single ExplicitComponent in Julia instead of Python. The goal of this tutorial is to minimize the paraboloid","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"f(xy) = (x - 30)^2 + xy + (y + 40)^2 - 30","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"with respect to x and y. The OpenMDAO docs say the answer is x = frac203 approx 6667 and y = -frac223 approx -7333. Let's find out!","category":"page"},{"location":"simple_paraboloid/#The-Python-Implementation","page":"A Simple Example","title":"The Python Implementation","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"One possible Python implementation of the above paraboloid is this:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"import openmdao.api as om\n\n\nclass Paraboloid(om.ExplicitComponent):\n    \"\"\"\n    Evaluates the equation f(x,y) = (x-3)^2 + xy + (y+4)^2 - 3.\n    \"\"\"\n\n    def setup(self):\n        self.add_input('x', val=0.0)\n        self.add_input('y', val=0.0)\n\n        self.add_output('f_xy', val=0.0)\n\n        # Finite difference all partials.\n        self.declare_partials('*', '*', method='fd')\n\n    def compute(self, inputs, outputs):\n        \"\"\"\n        f(x,y) = (x-3)^2 + xy + (y+4)^2 - 3\n\n        Minimum at: x = 6.6667; y = -7.3333\n        \"\"\"\n        x = inputs['x']\n        y = inputs['y']\n\n        outputs['f_xy'] = (x - 3.0)**2 + x * y + (y + 4.0)**2 - 3.0","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Not too bad. How do we do it in Julia?","category":"page"},{"location":"simple_paraboloid/#The-Julia-Implementation","page":"A Simple Example","title":"The Julia Implementation","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Like this, using OpenMDAOCore.jl:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore\n\nstruct Paraboloid <: OpenMDAOCore.AbstractExplicitComp\nend\n\nfunction OpenMDAOCore.setup(self::Paraboloid)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\", method=\"fd\")]\n    return inputs, outputs, partials\nend\n\nfunction OpenMDAOCore.compute!(self::Paraboloid, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"What does all that mean? We'll go through it step by step.","category":"page"},{"location":"simple_paraboloid/#Step-1:-Preamble","page":"A Simple Example","title":"Step 1: Preamble","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This line loads the OpenMDAOCore.jl Julia package. Julia uses two different keywords for loading code from Julia modules: using and import. The official Julia docs on Modules do a good job of explaining the difference. I like doing using Foo: Foo because it brings the module name Foo into the current scope, but not any of the names inside of Foo, so it doesn't clutter the namespace. (The statement using Foo: Foo is kind of like Julia's version of import foo in Python, while just plain using Foo is like Python's from foo import *.)","category":"page"},{"location":"simple_paraboloid/#Step-2:-The-Paraboloid-struct","page":"A Simple Example","title":"Step 2: The Paraboloid struct","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"struct Paraboloid <: OpenMDAOCore.AbstractExplicitComp\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This bit of code defines a new type in Julia named Paraboloid. The <: is the subtype operator in Julia, so we are telling Julia that our new Paraboloid type is a subtype of the AbstractExplicitComp type defined in OpenMDAOCore. This is the Julian equivalent of","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"class Paraboloid(om.ExplicitComponent):","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"in Python.","category":"page"},{"location":"simple_paraboloid/#Step-3:-OpenMDAOCore.setup","page":"A Simple Example","title":"Step 3: OpenMDAOCore.setup","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"function OpenMDAOCore.setup(self::Paraboloid)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\", method=\"fd\")]\n    return inputs, outputs, partials\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This OpenMDAOCore.setup method is the Julian equivalent of the ExplicitComponent.setup method from the Python version of the paraboloid. The job of OpenMDAOCore.setup is to take a single argument (an OpenMDAOCore.AbstractExplicitComp or OpenMDAOCore.AbstractImplicitComp) and return three things:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"A Vector of VarData structs containing metadata for the inputs to the component\nA Vector of VarData structs containing metadata for the outputs of the component\nA Vector of PartialsData structs containing metadata for the partial derivatives of the component","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"These Julia Vectors must always be returned in that order: inputs, outputs, partials. OpenMDAO.jl uses the VarData entries in the inputs and outputs Vectors to construct arguments to the Component.add_input and Component.add_output, respectively. And OpenMDAO.jl uses the PartialsData entries in the partials Vector to construct arguments to Component.declare_partials. The OpenMDAOCore.VarData and OpenMDAOCore.PartialsData docstrings have all the details.","category":"page"},{"location":"simple_paraboloid/#Step-4:-OpenMDAOCore.compute!","page":"A Simple Example","title":"Step 4: OpenMDAOCore.compute!","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"function OpenMDAOCore.compute!(self::Paraboloid, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"This OpenMDAOCore.compute! method is the equivalent of the Paraboloid.compute method from the Python version of the Paraboloid. Its job is to take a Paraboloid struct and a Dict of inputs, calculate the outputs, and then store these outputs in the outputs Dict. The inputs and outputs Dict entries are Julia arrays, similar to the NumPy arrays that OpenMDAO uses. (They are actually PyArrays from the PythonCall package, which are wrappers around the NumPy arrays that OpenMDAO creates for us.)","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now we need to figure out how to get that Julia code into OpenMDAO. How we do that depends on whether we're following the Python-Centric Approach or Julia-Centric Approach.","category":"page"},{"location":"simple_paraboloid/#The-Python-Centric-Run-Script","page":"A Simple Example","title":"The Python-Centric Run Script","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We'll use JuliaCall, provided by the PythonCall package, to import the Julia code from the previous section into Python. Then we can use the omjlcomps Python package to create an OpenMDAO ExplicitComponent from the Paraboloid Julia struct, and write a run script as usual.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"import openmdao.api as om\n\n# Create a new Julia module that will hold all the Julia code imported into this Python module.\nimport juliacall; jl = juliacall.newmodule(\"ParaboloidExample\")\n\n# This assumes the file with the Julia Paraboloid implementation is in the current directory and is named `paraboloid.jl`.\njl.include(\"paraboloid.jl\")\n# Now we have access to everything in `paraboloid.jl`.\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\nfrom omjlcomps import JuliaExplicitComp\ncomp = JuliaExplicitComp(jlcomp=jl.Paraboloid())\n\n# Now everything else is the same as https://openmdao.org/newdocs/versions/latest/basic_user_guide/single_disciplinary_optimization/first_analysis.html\nmodel = om.Group()\nmodel.add_subsystem('parab_comp', comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options['optimizer'] = 'SLSQP'\n\nprob.model.add_design_var('parab_comp.x')\nprob.model.add_design_var('parab_comp.y')\nprob.model.add_objective('parab_comp.f_xy')\n\nprob.setup()\n\nprob.set_val('parab_comp.x', 3.0)\nprob.set_val('parab_comp.y', -4.0)\n\nprob.run_model()\nprint(prob['parab_comp.f_xy'])  # Should print `[-15.]`\n\nprob.set_val('parab_comp.x', 5.0)\nprob.set_val('parab_comp.y', -2.0)\n\nprob.run_model()\nprint(prob.get_val('parab_comp.f_xy'))  # Should print `[-5.]`\n\nprob.run_driver()\nprint(f\"f_xy = {prob.get_val('parab_comp.f_xy')}\")  # Should print `[-27.33333333]`\nprint(f\"x = {prob.get_val('parab_comp.x')}\")  # Should print `[6.66666633]`\nprint(f\"y = {prob.get_val('parab_comp.y')}\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"The above Python run script should look pretty familiar if you have experience using OpenMDAO. The only difference from a pure-Python version is the little bit at the top that we use to create the JuliaExplicitComp.","category":"page"},{"location":"simple_paraboloid/#The-Julia-Centric-Run-Script","page":"A Simple Example","title":"The Julia-Centric Run Script","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now let's see if we can write a Julia run script:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAO: om, make_component\n\nprob = om.Problem()\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\ncomp = make_component(Paraboloid())\n\nmodel = om.Group()\nmodel.add_subsystem(\"parab_comp\", comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\n\nprob.model.add_design_var(\"parab_comp.x\")\nprob.model.add_design_var(\"parab_comp.y\")\nprob.model.add_objective(\"parab_comp.f_xy\")\n\nprob.setup()\n\nprob.set_val(\"parab_comp.x\", 3.0)\nprob.set_val(\"parab_comp.y\", -4.0)\n\nprob.run_model()\nprintln(prob[\"parab_comp.f_xy\"])  # Should print `[-15.]`\n\nprob.set_val(\"parab_comp.x\", 5.0)\nprob.set_val(\"parab_comp.y\", -2.0)\n\nprob.run_model()\nprintln(prob.get_val(\"parab_comp.f_xy\"))  # Should print `[-5.]`\n\nprob.run_driver()\nprintln(\"f_xy = $(prob.get_val(\"parab_comp.f_xy\"))\")  # Should print `[-27.33333333]`\nprintln(\"x = $(prob.get_val(\"parab_comp.x\"))\")  # Should print `[6.66666633]`\nprintln(\"y = $(prob.get_val(\"parab_comp.y\"))\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"(This example assumes that the definition of the Paraboloid struct is included in the same file. So concatenate those two code blocks if you'd like to run this yourself.) Good news—we got the expected answer!","category":"page"},{"location":"simple_paraboloid/#Adding-Derivatives","page":"A Simple Example","title":"Adding Derivatives","text":"","category":"section"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"In the previous example we used OpenMDAO's finite difference method to approximate the paraboloid's partial derivatives. We can calculate them ourselves, though, just like in a Python OpenMDAO Component. Here's the implementation:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAOCore: OpenMDAOCore\n\nstruct ParaboloidUserPartials <: OpenMDAOCore.AbstractExplicitComp\nend\n\nfunction OpenMDAOCore.setup(self::ParaboloidUserPartials)\n    inputs = [OpenMDAOCore.VarData(\"x\", val=0.0), OpenMDAOCore.VarData(\"y\", val=0.0)]\n    outputs = [OpenMDAOCore.VarData(\"f_xy\", val=0.0)]\n    partials = [OpenMDAOCore.PartialsData(\"*\", \"*\")]\n    return inputs, outputs, partials\nend\n\nfunction OpenMDAOCore.compute!(self::ParaboloidUserPartials, inputs, outputs)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    outputs[\"f_xy\"][1] = (x - 3.0)^2 + x * y + (y + 4.0)^2 - 3.0\n\n    return nothing\nend\n\nfunction OpenMDAOCore.compute_partials!(self::ParaboloidUserPartials, inputs, partials)\n    x = inputs[\"x\"][1]\n    y = inputs[\"y\"][1]\n\n    partials[\"f_xy\", \"x\"][1] = 2*(x - 3.0) + y\n    partials[\"f_xy\", \"y\"][1] = x + 2*(y + 4.0)\n\n    return nothing\nend","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"The implementation of ParaboloidUserPartials is almost the same as Paraboloid. The are only two differences:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"We've removed the method=\"fd\" argument from the call to the PartialsData constructor. This means the method argument will default to \"exact\" (as shown in the docstring above), and OpenMDAO will expect we'll calculate the derivatives of this component ourselves.\nWe've implemented a compute_partials! method for our new ParaboloidUserPartials struct. This is just like an ExplicitComponent.compute_partials method in a Python OpenMDAO component. Its job is to calculate the the derivatives of the outputs with respect to the inputs, of course.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"So, we implemented a compute_partials! method. But how do we know if they're right? The OpenMDAO Problem class has a method called check_partials that compares the user-defined partial derivatives to the finite difference method. Can we use that with an OpenMDAOCore.AbstractExplicitComp? Let's try!","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"using OpenMDAO: om, make_component\n\nprob = om.Problem()\n\n# omjlcomps knows how to create an OpenMDAO ExplicitComponent from an OpenMDAOCore.AbstractExplicitComp\ncomp = make_component(ParaboloidUserPartials())\n\nmodel = om.Group()\nmodel.add_subsystem(\"parab_comp\", comp)\n\nprob = om.Problem(model)\n\nprob.driver = om.ScipyOptimizeDriver()\nprob.driver.options[\"optimizer\"] = \"SLSQP\"\n\nprob.model.add_design_var(\"parab_comp.x\")\nprob.model.add_design_var(\"parab_comp.y\")\nprob.model.add_objective(\"parab_comp.f_xy\")\n\nprob.setup(force_alloc_complex=true)\n\nprob.set_val(\"parab_comp.x\", 3.0)\nprob.set_val(\"parab_comp.y\", -4.0)\n\nprob.run_model()\nprintln(prob.check_partials(method=\"fd\"))","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"It worked! And the error is quite small.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"What about the complex step method?","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"println(prob.check_partials(method=\"cs\"))","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"It works! (The error is zero since the complex-step method is second-order accurate and we're differentiating a second-order polynomial.) Complex numbers are no problem for Julia, but just like Python, we need to be careful to write our compute_partials! function in a complex-step-safe manner.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"note: FLOWMath.jl\nThe Julia library FLOWMath has a collection of complex-step-safe functions.","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Now, let's try an optimization:","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"prob.run_driver()\nprintln(\"f_xy = $(prob.get_val(\"parab_comp.f_xy\"))\")  # Should print `[-27.33333333]`\nprintln(\"x = $(prob.get_val(\"parab_comp.x\"))\")  # Should print `[6.66666633]`\nprintln(\"y = $(prob.get_val(\"parab_comp.y\"))\")  # Should print `[-7.33333367]`","category":"page"},{"location":"simple_paraboloid/","page":"A Simple Example","title":"A Simple Example","text":"Still works, and we got the right answer.","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"brachistochrone/#A-Simple-Dymos-Example","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We can also use OpenMDAO.jl Components within a Dymos ODE. This example will implement the Brachistochrone example from the Dymos docs using Julia.","category":"page"},{"location":"brachistochrone/#Preamble","page":"A Simple Dymos Example","title":"Preamble","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"Let's make things easier on ourselves and import the VarData and PartialsData names into our local namespace:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using OpenMDAOCore: OpenMDAOCore, VarData, PartialsData","category":"page"},{"location":"brachistochrone/#The-AbstractExplicitComp-struct","page":"A Simple Dymos Example","title":"The AbstractExplicitComp struct","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The ODE component for the brachistochrone has two options:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"num_nodes, the number of nodes used to descritize the trajectory of the bead.\nstatic_gravity, a flag to indicate whether gravity should vary along the trajectory (and thus have length num_nodes) or if it should be constant (and thus be a scalar).","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We'll use a default value of false for static_gravity, just like the Python implementation in the Dymos docs:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"struct BrachistochroneODE <: OpenMDAOCore.AbstractExplicitComp\n    num_nodes::Int\n    static_gravity::Bool\nend\n\n# `static_gravity` set to `false` by default.\nBrachistochroneODE(; num_nodes, static_gravity=false) = BrachistochroneODE(num_nodes, static_gravity)","category":"page"},{"location":"brachistochrone/#OpenMDAOCore.setup","page":"A Simple Dymos Example","title":"OpenMDAOCore.setup","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"Next we'll define the OpenMDAOCore.setup function:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.setup(self::BrachistochroneODE)\n\tnn = self.num_nodes\n\n\t# Inputs\n    input_data = Vector{VarData}()\n    push!(input_data, VarData(\"v\"; val=zeros(nn), units=\"m/s\"))\n\tif self.static_gravity\n        push!(input_data, VarData(\"g\", val=9.80665, units=\"m/s/s\", tags=[\"dymos.static_target\"]))\n\telse\n        push!(input_data, VarData(\"g\", val=9.80665 * ones(nn), units=\"m/s/s\"))\n    end\n    push!(input_data, VarData(\"theta\", val=ones(nn), units=\"rad\"))\n\n    # Outputs\n    output_data = Vector{VarData}()\n    push!(output_data, VarData(\"xdot\", val=zeros(nn), units=\"m/s\", tags=[\"dymos.state_rate_source:x\", \"dymos.state_units:m\"]))\n    push!(output_data, VarData(\"ydot\", val=zeros(nn), units=\"m/s\", tags=[\"dymos.state_rate_source:y\", \"dymos.state_units:m\"]))\n    push!(output_data, VarData(\"vdot\", val=zeros(nn), units=\"m/s**2\", tags=[\"dymos.state_rate_source:v\", \"dymos.state_units:m/s\"]))\n    push!(output_data, VarData(\"check\", val=zeros(nn), units=\"m/s\"))\n\n    # Setup partials\n    arange = 0:nn-1\n    partials_data = Vector{PartialsData}()\n    push!(partials_data, PartialsData(\"vdot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"xdot\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"xdot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"ydot\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"ydot\", \"theta\"; rows=arange, cols=arange))\n\n    push!(partials_data, PartialsData(\"check\", \"v\"; rows=arange, cols=arange))\n    push!(partials_data, PartialsData(\"check\", \"theta\"; rows=arange, cols=arange))\n\n\tif self.static_gravity\n\t\tc = zeros(Int, self.num_nodes)\n        push!(partials_data, PartialsData(\"vdot\", \"g\"; rows=arange, cols=c))\n\telse\n        push!(partials_data, PartialsData(\"vdot\", \"g\"; rows=arange, cols=arange))\n    end\n\n    return input_data, output_data, partials_data\nend","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"This is probably the most complicated setup we've seen yet. A few things to note:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We can change the size of the g (gravity) input and its sub-Jacobian using the static_gravity option in the BrachistochroneODE struct.\nThe VarData calls use tags, which are passed to the ExplicitComponent.add_input method using the tags keyword argument in OpenMDAO.\nAs we'll see, the job of a Dymos ODE is to compute the state rates from the states and controls. It turns out that in many (all) ODEs, these state rates for a given trajectory node only depend on the state and controls at that particular node. This implies that the Jacobian of the ODE calculation will be sparse. This example, like the original Python implementation, passes the sparsity pattern of the various sub-Jacobians to the PartialsData structs using the rows and cols keywords.","category":"page"},{"location":"brachistochrone/#OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!","page":"A Simple Dymos Example","title":"OpenMDAOCore.compute! and OpenMDAOCore.compute_partials!","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The OpenMDAOCore.compute! method for our ODE is fairly straightforward:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.compute!(self::BrachistochroneODE, inputs, outputs)\n\ttheta = inputs[\"theta\"]\n\tcos_theta = cos.(theta)\n\tsin_theta = sin.(theta)\n\tg = inputs[\"g\"]\n\tv = inputs[\"v\"]\n\n\t@. outputs[\"vdot\"] = g * cos_theta\n\t@. outputs[\"xdot\"] = v * sin_theta\n\t@. outputs[\"ydot\"] = -v * cos_theta\n\t@. outputs[\"check\"] = v / sin_theta\n\n    return nothing\nend","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The @. macro tells Julia to use broadcasting for the array calculations (similar to NumPy broadcasting).","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"The compute_partials! method is also quite similar to the original Python implementation:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"function OpenMDAOCore.compute_partials!(self::BrachistochroneODE, inputs, partials)\n\ttheta = inputs[\"theta\"]\n\tcos_theta = cos.(theta)\n\tsin_theta = sin.(theta)\n\tg = inputs[\"g\"]\n\tv = inputs[\"v\"]\n\n\t@. partials[\"vdot\", \"g\"] = cos_theta\n\t@. partials[\"vdot\", \"theta\"] = -g * sin_theta\n\n\t@. partials[\"xdot\", \"v\"] = sin_theta\n\t@. partials[\"xdot\", \"theta\"] = v * cos_theta\n\n\t@. partials[\"ydot\", \"v\"] = -cos_theta\n\t@. partials[\"ydot\", \"theta\"] = v * sin_theta\n\n\t@. partials[\"check\", \"v\"] = 1 / sin_theta\n\t@. partials[\"check\", \"theta\"] = -v * cos_theta / sin_theta ^ 2\n\n\treturn nothing\nend","category":"page"},{"location":"brachistochrone/#The-run-script","page":"A Simple Dymos Example","title":"The run script","text":"","category":"section"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"We'll need the Dymos library to solve the Brachistochrone problem, of course:","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using PythonCall: pyimport\ndm = pyimport(\"dymos\")","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"And then the rest of the script will be pretty much identical to the Python version, but written in Julia. We'll put it in a function that allows us to try out static_gravity=false and static_gravity=true.","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"using OpenMDAO: om, make_component, DymosifiedCompWrapper\n\nfunction main(; static_gravity)\n  #\n  # Initialize the Problem and the optimization driver\n  #\n  p = om.Problem(model=om.Group())\n  p.driver = om.ScipyOptimizeDriver()\n  p.driver.declare_coloring()\n  #\n  # Create a trajectory and add a phase to it\n  #\n  traj = p.model.add_subsystem(\"traj\", dm.Trajectory())\n\n  # `Trajectory.add_phase` expects a class that it can instantiate with the number of nodes used for the phase.\n  # That's easy enough to create with an anonymous function, but unfortunatly it won't work with Dymos (because of the way JuliaCall implements truthiness/falsiness of Julia callables).\n  # So, as a workaround, OpenMDAO.jl has a small wrapper `struct` that will fix this for us called `DymosifiedCompWrapper`.\n  # The way this works: we give DymosifiedCompWrapper the ODE type (not a type instance, the type itself), and the keyword arguments we need to instantiate the type, other than `num_nodes`.\n  # Check out the docstring for an example.\n  dcw = DymosifiedCompWrapper(BrachistochroneODE; static_gravity=static_gravity)\n  phase = traj.add_phase(\"phase0\",\n                         dm.Phase(ode_class = dcw,\n                                  transcription = dm.GaussLobatto(num_segments=10)))\n\n  #\n  # Set the variables\n  #\n  phase.set_time_options(fix_initial=true, duration_bounds=(.5, 10))\n\n  phase.add_state(\"x\", fix_initial=true, fix_final=true)\n\n  phase.add_state(\"y\", fix_initial=true, fix_final=true)\n\n  phase.add_state(\"v\", fix_initial=true, fix_final=false)\n\n  phase.add_control(\"theta\", continuity=true, rate_continuity=true,\n                    units=\"deg\", lower=0.01, upper=179.9)\n\n  phase.add_parameter(\"g\", units=\"m/s**2\", val=9.80665)\n\n  #\n  # Minimize time at the end of the phase\n  #\n  phase.add_objective(\"time\", loc=\"final\", scaler=10)\n  # \n  p.model.linear_solver = om.DirectSolver()\n  #\n  # Setup the Problem\n  #\n  p.setup()\n\n  #\n  # Set the initial values\n  #\n  p[\"traj.phase0.t_initial\"] = 0.0\n  p[\"traj.phase0.t_duration\"] = 2.0\n\n  p.set_val(\"traj.phase0.states:x\", phase.interp(\"x\", ys=[0, 10]))\n  p.set_val(\"traj.phase0.states:y\", phase.interp(\"y\", ys=[10, 5]))\n  p.set_val(\"traj.phase0.states:v\", phase.interp(\"v\", ys=[0, 9.9]))\n  p.set_val(\"traj.phase0.controls:theta\", phase.interp(\"theta\", ys=[5, 100.5]))\n\n  #\n  # Solve for the optimal trajectory\n  #\n  dm.run_problem(p)\n\n  # Check the results\n  println(\"static_gravity = $static_gravity, elapsed time = $(p.get_val(\"traj.phase0.timeseries.time\")[-1]) (should be 1.80164719)\")\nend\n\nmain(; static_gravity=false)\nmain(; static_gravity=true)","category":"page"},{"location":"brachistochrone/","page":"A Simple Dymos Example","title":"A Simple Dymos Example","text":"At the end we see we got pretty much the same answer for the elapsed time as the Python example in the Dymos docs. (But not exactly the same, which is a bummer...)","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"limitations/#Limitations","page":"Limitations","title":"Limitations","text":"","category":"section"},{"location":"limitations/#Import-juliacall-first-from-Python...-sometimes","page":"Limitations","title":"Import juliacall first from Python... sometimes","text":"","category":"section"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"When using the omjlcomps Python library, it is sometimes necessary to import juliacall before other Python libraries (at least matplotlib, maybe others too) to avoid an error that looks like this:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"$ cat test.py\nimport matplotlib\nimport juliacall\n$ python test.py\nERROR: `ccall` requires the compilerTraceback (most recent call last):\n  File \"/home/dingraha/desk/pythoncall_wtf/test.py\", line 2, in <module>\n    import juliacall\n  File \"/home/dingraha/desk/pythoncall_wtf/venv-mybuild-with-libc-enable-shared-without-lto-without-optimizations-computed-gotos-no-dtrace-no-ssl/lib/python3.9/site-packages/juliacall/__init__.py\", line 218, in <module>\n    init()\n  File \"/home/dingraha/desk/pythoncall_wtf/venv-mybuild-with-libc-enable-shared-without-lto-without-optimizations-computed-gotos-no-dtrace-no-ssl/lib/python3.9/site-packages/juliacall/__init__.py\", line 214, in init\n    raise Exception('PythonCall.jl did not start properly')\nException: PythonCall.jl did not start properly\n$","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"This only occurs when using the system Python on certain Linux distributions (e.g., Python 3.9.7 on Red Hat Enterprise Linux 8.6). I've found three workarounds:","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"import the juliacall module first in your run script, before anything else, or\ndon't use the system Python: set up a Conda environment instead, or\ndon't use RHEL (the system Python on e.g. Arch Linux doesn't appear to suffer from this bug).","category":"page"},{"location":"limitations/","page":"Limitations","title":"Limitations","text":"See this PythonCall issue for a few more details.","category":"page"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"reference/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"reference/","page":"API Reference","title":"API Reference","text":"Modules = [OpenMDAOCore, OpenMDAO]","category":"page"},{"location":"reference/#OpenMDAOCore.PartialsData","page":"API Reference","title":"OpenMDAOCore.PartialsData","text":"PartialsData(of::String, wrt::String; <keyword arguments>)\n\nCreate a PartialsData object for the derivative of variable of with respect to variable wrt.\n\nPartialsData objects are used to construct arguments to OpenMDAO's Component.declare_partials method. Specifically, a PartialsData object pd will eventually be used to call Component.declare_partials like this:\n\nComponent.declare_partials(pd.of, pd.wrt, rows=pd.rows, cols=pd.cols, val=pd.val, method=pd.method)\n\nThe of and wrt positional arguments are required and set the of and wrt fields. The value of the other PartialsData fields (e.g., pd.rows, pd.val, etc.) are set via constructor keyword arguments, here:\n\nKeyword Arguments\n\nrows::Union{<:AbstractVector{Int64},Nothing} = nothing: row indices for each non-zero Jacobian entry, if not nothing.\ncols::Union{<:AbstractVector{Int64},Nothing} = nothing: column indices for each non-zero Jacobian entry, if not nothing.\nval::Union{Float64,<:AbstractArray{Float64},Nothing} = nothing: value of Jacobian, if not nothing.\nmethod::String = \"exact\": method use to calcluate the partial derivative(s). Should be one of\n\"exact\": user-defined partial derivatives via compute_partials!, linearize!, etc.\n\"fd\": finite difference approximation\n\"cs\": complex step approximation\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAOCore.VarData","page":"API Reference","title":"OpenMDAOCore.VarData","text":"VarData(name::String; <keyword arguments>)\n\nCreate a VarData object for an OpenMDAO variable named name.\n\nVarData objects are used to construct arguments to OpenMDAO's Component.add_input and Component.add_output methods. Specifically, if a VarData object var refers to an input variable, the Component.add_input call will look like this:\n\nComponent.add_input(var.name, shape=var.shape, val=var.val, units=var.units, tags=var.tags, shape_by_conn=var.shape_by_conn)\n\nand if the VarData object var is an output variable, the Component.add_output call will look like this:\n\nComponent.add_output(var.name, shape=var.shape, val=var.val, units=var.units, lower=var.lower, upper=var.upper, tags=var.tags, shape_by_conn=var.shape_by_conn)\n\nThe name positional argument is required and sets the name field. The value of the other VarData fields (e.g., var.shape, var.val, etc.) are set via constructor keyword arguments, here:\n\nKeyword Arguments\n\nval::Union{Float64,<:AbstractArray{Float64},Nothing} = 1.0: variable's default value, set to 1.0 if nothing.\nshape::Union{Int64,NTuple{N,Int64},Nothing} = (1,): variable shape, set to (1,) if nothing.\nunits::Union{String,Nothing} = nothing: variable units.\nlower::Union{Float64,<:AbstractArray{Float64,N},Nothing} = nothing: variable's lower limit.\nupper::Union{Float64,<:AbstractArray{Float64,N},Nothing} = nothing: variable's upper limit.\ntags::Union{<:AbstractVector{String},Nothing} = nothing: variable tags.\nshape_by_conn::Bool = false: if true, shape this variable by its connected output (if an input) or input (if an output)\ncopy_shape::Union{String,Nothing} = nothing: if a string, shape this variable by the local variable indicated by copy_shape\n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAO.DymosifiedCompWrapper","page":"API Reference","title":"OpenMDAO.DymosifiedCompWrapper","text":"DymosifiedCompWrapper{Tkwargs}\n\nWrapper type that stores a type (not an instance) of an <:OpenMDAOCore.AbstractComp and the non-num_nodes keyword arguments (if any) used to construct the instance.\n\nExample\n\njulia> using OpenMDAOCore: OpenMDAOCore\n\njulia> using OpenMDAO\n\njulia> struct FooODE <: OpenMDAOCore.AbstractExplicitComp\n         num_nodes::Int\n         a::Float64\n       end\n\njulia> FooODE(; num_nodes, a) = FooODE(num_nodes, a)\nFooODE\n\njulia> dcw = OpenMDAO.DymosifiedCompWrapper(FooODE; a=8.0)\nOpenMDAO.DymosifiedCompWrapper{Base.Pairs{Symbol, Float64, Tuple{Symbol}, NamedTuple{(:a,), Tuple{Float64}}}}(FooODE, Base.Pairs(:a => 8.0))\n\njulia> comp = dcw(num_nodes=4)\nPython JuliaExplicitComp: <omjlcomps.JuliaExplicitComp object at 0x7f38429333a0>\n\njulia> \n\n\n\n\n\n","category":"type"},{"location":"reference/#OpenMDAO.DymosifiedCompWrapper-Tuple{Any}","page":"API Reference","title":"OpenMDAO.DymosifiedCompWrapper","text":"DymosifiedCompWrapper(TComp::Type{<:OpenMDAOCore.AbstractComp}; kwargs...)\n\nConstruct a wrapper to a <:OpenMDAOCore.AbstractComp that can be used to create a omjlcomps.JuliaExplicitComp or omjlcomps.JuliaImplicitComp by just passing a num_nodes argument.\n\nArguments\n\nTComp: An OpenMDAOCore.AbstractComp type, not an instance (so TComp = FooComp, not TComp = FooComp(), analogous to the difference between Float64 and 1.0),\nkwargs: keyword arguments, other than num_nodes, that are needed to construct an instance of TComp\n\nExample\n\njulia> using OpenMDAOCore: OpenMDAOCore\n\njulia> using OpenMDAO\n\njulia> struct FooODE <: OpenMDAOCore.AbstractExplicitComp\n         num_nodes::Int\n         a::Float64\n       end\n\njulia> FooODE(; num_nodes, a) = FooODE(num_nodes, a)\nFooODE\n\njulia> dcw = OpenMDAO.DymosifiedCompWrapper(FooODE; a=8.0)\nOpenMDAO.DymosifiedCompWrapper{Base.Pairs{Symbol, Float64, Tuple{Symbol}, NamedTuple{(:a,), Tuple{Float64}}}}(FooODE, Base.Pairs(:a => 8.0))\n\njulia> comp = dcw(num_nodes=4)\nPython JuliaExplicitComp: <omjlcomps.JuliaExplicitComp object at 0x7f38429333a0>\n\njulia> \n\n\n\n\n\n","category":"method"},{"location":"reference/#OpenMDAO.make_component","page":"API Reference","title":"OpenMDAO.make_component","text":"make_component(comp::OpenMDAOCore.AbstractComp)\n\nConvinience method for creating either a JuliaExplicitComp or JuliaImplicitComp, depending on if comp is <:OpenMDAOCore.AbstractExplicitComp or <:OpenMDAOCore.AbstractImplicitComp, respectively.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = OpenMDAODocs","category":"page"},{"location":"#OpenMDAO.jl-Documentation","page":"Home","title":"OpenMDAO.jl Documentation","text":"","category":"section"},{"location":"#What?","page":"Home","title":"What?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Use Julia with OpenMDAO! OpenMDAO.jl is a Julia package that allows a user to:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Write OpenMDAO Components in Julia, and incorporate these components into a OpenMDAO model.\nCreate and run optimizations in Julia, using OpenMDAO as a library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenMDAO.jl consists of three pieces of software:","category":"page"},{"location":"","page":"Home","title":"Home","text":"OpenMDAOCore.jl: A small, pure-Julia package that allows users to define Julia code that will eventually be used in an OpenMDAO Problem. OpenMDAOCore.jl defines two Julia abstract types (AbstractExplicitComponent and AbstractImplicitComponent) and methods that mimic OpenMDAO's ExplicitComponent and ImplicitComponent classes.\nomjlcomps: A Python package (actually, a OpenMDAO Plugin) that defines two classes, JuliaExplicitComp and JuliaImplicitComp, which inherit from OpenMDAO's ExplicitComponent and ImplicitComponent, respectively. These components takes instances of concrete subtypes of OpenMDAOCore.ExplicitComponent and OpenMDAOCore.ImplicitComponent and turn them into instances of JuliaExplicitComp and JuliaImplicitComp. Like any other OpenMDAO ExplicitComponent or ImplicitComponent objects, JuliaExplicitComp and JuliaImplicitComp instances can be used in an OpenMDAO model, but call Julia code in their methods (compute, apply_nonlinear, etc.).\nOpenMDAO.jl: A Julia package that has the openmdao and omjlcomps Python packages as dependencies. Users can install OpenMDAO.jl and have the full power of the OpenMDAO framework at their disposal in Julia.","category":"page"},{"location":"#How-(Installation-Instructions)?","page":"Home","title":"How (Installation Instructions)?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"There are two approaches to getting OpenMDAO working with Julia: the Python-Centric Approach and the Julia-Centric Approach. If you like Python and just want to have a little (or a lot) of Julia buried in your OpenMDAO System, then you'll probably prefer the Python-centric approach. If you're a huge fan of Julia and would like to pretend that OpenMDAO is a Julia library, you'll want the Julia-centric approach. Either way, pick one or the other: you don't need to follow both installation instructions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note At the moment OpenMDAO.jl is not registered in the Julia General registry, so installing it from the Pkg prompt with ] add OpenMDAOwill fail on a vanilla Julia installation. It is registered in the official™ DanielIngrahamRegistry, however, so if you'd like an automatic installation process, just do this from the Julia Pkg prompt:pkg> registry add git@github.com:dingraha/DanielIngrahamRegistry.git","category":"page"},{"location":"#python_centric","page":"Home","title":"Python-Centric Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The first (and only!) step is to install omjlcomps, which is in the Python Package Index, so a simple","category":"page"},{"location":"","page":"Home","title":"Home","text":"pip install omjlcomps","category":"page"},{"location":"","page":"Home","title":"Home","text":"should be all you need. omjlcomps uses JuliaPkg to manage Julia dependencies, so all the Julia packages needed by omjlcomps (and even Julia itself, if necessary) will be installed automatically.","category":"page"},{"location":"#julia_centric","page":"Home","title":"Julia-Centric Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The OpenMDAOCore.jl and OpenMDAO.jl Julia package are the official™ DanielIngrahamRegistry, so if you have access to that, installation should be as simple as","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add OpenMDAOCore OpenMDAO","category":"page"},{"location":"","page":"Home","title":"Home","text":"in the Julia REPL. OpenMDAOCore.jl is a fairly small package without any Python dependencies, but OpenMDAO.jl depends on omjlcomps and openmdao itself. OpenMDAO.jl's Python dependencies are managed by CondaPkg, and should be automatically installed into a separate Conda environment specific to your current Julia environment.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"An early version of OpenMDAO.jl was written by Daniel Ingraham, Justin Gray, and Andrew Ning while visiting Prof. Ning at Brigham Young University.\nOpenMDAO.jl depends heavily on PythonCall and related packages, developed by Christopher Rowley.","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A Simple Dymos Example · OpenMDAO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpenMDAO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simple_paraboloid/">A Simple Example</a></li><li><a class="tocitem" href="../nonlinear_circuit/">A More Complicated Example</a></li><li><a class="tocitem" href="../shape_by_conn/">Variable Shapes at Runtime</a></li><li class="is-active"><a class="tocitem" href>A Simple Dymos Example</a><ul class="internal"><li><a class="tocitem" href="#Preamble"><span>Preamble</span></a></li><li><a class="tocitem" href="#The-AbstractExplicitComp-struct"><span>The <code>AbstractExplicitComp</code> <code>struct</code></span></a></li><li><a class="tocitem" href="#OpenMDAOCore.setup"><span><code>OpenMDAOCore.setup</code></span></a></li><li><a class="tocitem" href="#OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!"><span><code>OpenMDAOCore.compute!</code> and <code>OpenMDAOCore.compute_partials!</code></span></a></li><li><a class="tocitem" href="#The-run-script"><span>The run script</span></a></li></ul></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../dev_docs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>A Simple Dymos Example</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A Simple Dymos Example</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/master/docs/src/brachistochrone.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="A-Simple-Dymos-Example"><a class="docs-heading-anchor" href="#A-Simple-Dymos-Example">A Simple Dymos Example</a><a id="A-Simple-Dymos-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-Simple-Dymos-Example" title="Permalink"></a></h1><p>We can also use OpenMDAO.jl Components within a Dymos ODE. This example will implement <a href="https://openmdao.github.io/dymos/examples/brachistochrone/brachistochrone.html">the Brachistochrone example from the Dymos docs</a> using Julia.</p><h2 id="Preamble"><a class="docs-heading-anchor" href="#Preamble">Preamble</a><a id="Preamble-1"></a><a class="docs-heading-anchor-permalink" href="#Preamble" title="Permalink"></a></h2><p>Let&#39;s make things easier on ourselves and import the <code>VarData</code> and <code>PartialsData</code> names into our local namespace:</p><pre><code class="language-julia hljs">using OpenMDAOCore: OpenMDAOCore, VarData, PartialsData</code></pre><h2 id="The-AbstractExplicitComp-struct"><a class="docs-heading-anchor" href="#The-AbstractExplicitComp-struct">The <code>AbstractExplicitComp</code> <code>struct</code></a><a id="The-AbstractExplicitComp-struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-AbstractExplicitComp-struct" title="Permalink"></a></h2><p>The ODE component for the brachistochrone has two options:</p><ul><li><code>num_nodes</code>, the number of nodes used to descritize the trajectory of the bead.</li><li><code>static_gravity</code>, a flag to indicate whether gravity should vary along the trajectory (and thus have length <code>num_nodes</code>) or if it should be constant (and thus be a scalar).</li></ul><p>We&#39;ll use a default value of <code>false</code> for <code>static_gravity</code>, just like the Python implementation in the Dymos docs:</p><pre><code class="language-julia hljs">struct BrachistochroneODE &lt;: OpenMDAOCore.AbstractExplicitComp
    num_nodes::Int
    static_gravity::Bool
end

# `static_gravity` set to `false` by default.
BrachistochroneODE(; num_nodes, static_gravity=false) = BrachistochroneODE(num_nodes, static_gravity)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Main.BrachistochroneODE</code></pre><h2 id="OpenMDAOCore.setup"><a class="docs-heading-anchor" href="#OpenMDAOCore.setup"><code>OpenMDAOCore.setup</code></a><a id="OpenMDAOCore.setup-1"></a><a class="docs-heading-anchor-permalink" href="#OpenMDAOCore.setup" title="Permalink"></a></h2><p>Next we&#39;ll define the <code>OpenMDAOCore.setup</code> function:</p><pre><code class="language-julia hljs">function OpenMDAOCore.setup(self::BrachistochroneODE)
	nn = self.num_nodes

	# Inputs
    input_data = Vector{VarData}()
    push!(input_data, VarData(&quot;v&quot;; val=zeros(nn), units=&quot;m/s&quot;))
	if self.static_gravity
        push!(input_data, VarData(&quot;g&quot;, val=9.80665, units=&quot;m/s/s&quot;, tags=[&quot;dymos.static_target&quot;]))
	else
        push!(input_data, VarData(&quot;g&quot;, val=9.80665 * ones(nn), units=&quot;m/s/s&quot;))
    end
    push!(input_data, VarData(&quot;theta&quot;, val=ones(nn), units=&quot;rad&quot;))

    # Outputs
    output_data = Vector{VarData}()
    push!(output_data, VarData(&quot;xdot&quot;, val=zeros(nn), units=&quot;m/s&quot;, tags=[&quot;dymos.state_rate_source:x&quot;, &quot;dymos.state_units:m&quot;]))
    push!(output_data, VarData(&quot;ydot&quot;, val=zeros(nn), units=&quot;m/s&quot;, tags=[&quot;dymos.state_rate_source:y&quot;, &quot;dymos.state_units:m&quot;]))
    push!(output_data, VarData(&quot;vdot&quot;, val=zeros(nn), units=&quot;m/s**2&quot;, tags=[&quot;dymos.state_rate_source:v&quot;, &quot;dymos.state_units:m/s&quot;]))
    push!(output_data, VarData(&quot;check&quot;, val=zeros(nn), units=&quot;m/s&quot;))

    # Setup partials
    arange = 0:nn-1
    partials_data = Vector{PartialsData}()
    push!(partials_data, PartialsData(&quot;vdot&quot;, &quot;theta&quot;; rows=arange, cols=arange))

    push!(partials_data, PartialsData(&quot;xdot&quot;, &quot;v&quot;; rows=arange, cols=arange))
    push!(partials_data, PartialsData(&quot;xdot&quot;, &quot;theta&quot;; rows=arange, cols=arange))

    push!(partials_data, PartialsData(&quot;ydot&quot;, &quot;v&quot;; rows=arange, cols=arange))
    push!(partials_data, PartialsData(&quot;ydot&quot;, &quot;theta&quot;; rows=arange, cols=arange))

    push!(partials_data, PartialsData(&quot;check&quot;, &quot;v&quot;; rows=arange, cols=arange))
    push!(partials_data, PartialsData(&quot;check&quot;, &quot;theta&quot;; rows=arange, cols=arange))

	if self.static_gravity
		c = zeros(Int, self.num_nodes)
        push!(partials_data, PartialsData(&quot;vdot&quot;, &quot;g&quot;; rows=arange, cols=c))
	else
        push!(partials_data, PartialsData(&quot;vdot&quot;, &quot;g&quot;; rows=arange, cols=arange))
    end

    return input_data, output_data, partials_data
end</code></pre><p>This is probably the most complicated <code>setup</code> we&#39;ve seen yet. A few things to note:</p><ul><li>We can change the size of the <code>g</code> (gravity) input and its sub-Jacobian using the <code>static_gravity</code> option in the <code>BrachistochroneODE</code> <code>struct</code>.</li><li>The <code>VarData</code> calls use <code>tags</code>, which are passed to the <code>ExplicitComponent.add_input</code> method using the <code>tags</code> keyword argument in OpenMDAO.</li><li>As we&#39;ll see, the job of a Dymos ODE is to compute the state rates from the states and controls. It turns out that in many (all) ODEs, these state rates for a given trajectory node only depend on the state and controls at that particular node. This implies that the Jacobian of the ODE calculation will be sparse. This example, like the original Python implementation, passes the sparsity pattern of the various sub-Jacobians to the <code>PartialsData</code> structs using the <code>rows</code> and <code>cols</code> keywords.</li></ul><h2 id="OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!"><a class="docs-heading-anchor" href="#OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!"><code>OpenMDAOCore.compute!</code> and <code>OpenMDAOCore.compute_partials!</code></a><a id="OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!-1"></a><a class="docs-heading-anchor-permalink" href="#OpenMDAOCore.compute!-and-OpenMDAOCore.compute_partials!" title="Permalink"></a></h2><p>The <code>OpenMDAOCore.compute!</code> method for our ODE is fairly straightforward:</p><pre><code class="language-julia hljs">function OpenMDAOCore.compute!(self::BrachistochroneODE, inputs, outputs)
	theta = inputs[&quot;theta&quot;]
	cos_theta = cos.(theta)
	sin_theta = sin.(theta)
	g = inputs[&quot;g&quot;]
	v = inputs[&quot;v&quot;]

	@. outputs[&quot;vdot&quot;] = g * cos_theta
	@. outputs[&quot;xdot&quot;] = v * sin_theta
	@. outputs[&quot;ydot&quot;] = -v * cos_theta
	@. outputs[&quot;check&quot;] = v / sin_theta

    return nothing
end</code></pre><p>The <code>@.</code> macro tells Julia to use <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a> for the array calculations (similar to NumPy broadcasting).</p><p>The <code>compute_partials!</code> method is also quite similar to the original Python implementation:</p><pre><code class="language-julia hljs">function OpenMDAOCore.compute_partials!(self::BrachistochroneODE, inputs, partials)
	theta = inputs[&quot;theta&quot;]
	cos_theta = cos.(theta)
	sin_theta = sin.(theta)
	g = inputs[&quot;g&quot;]
	v = inputs[&quot;v&quot;]

	@. partials[&quot;vdot&quot;, &quot;g&quot;] = cos_theta
	@. partials[&quot;vdot&quot;, &quot;theta&quot;] = -g * sin_theta

	@. partials[&quot;xdot&quot;, &quot;v&quot;] = sin_theta
	@. partials[&quot;xdot&quot;, &quot;theta&quot;] = v * cos_theta

	@. partials[&quot;ydot&quot;, &quot;v&quot;] = -cos_theta
	@. partials[&quot;ydot&quot;, &quot;theta&quot;] = v * sin_theta

	@. partials[&quot;check&quot;, &quot;v&quot;] = 1 / sin_theta
	@. partials[&quot;check&quot;, &quot;theta&quot;] = -v * cos_theta / sin_theta ^ 2

	return nothing
end</code></pre><h2 id="The-run-script"><a class="docs-heading-anchor" href="#The-run-script">The run script</a><a id="The-run-script-1"></a><a class="docs-heading-anchor-permalink" href="#The-run-script" title="Permalink"></a></h2><p>We&#39;ll need the Dymos library to solve the Brachistochrone problem, of course:</p><pre><code class="language-julia hljs">using PythonCall: pyimport
dm = pyimport(&quot;dymos&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;module &#39;dymos&#39; from &#39;/home/runner/work/OpenMDAO.jl/OpenMDAO.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/dymos/__init__.py&#39;&gt;</code></pre><p>And then the rest of the script will be pretty much identical to the Python version, but written in Julia. We&#39;ll put it in a function that allows us to try out <code>static_gravity=false</code> and <code>static_gravity=true</code>.</p><pre><code class="language-julia hljs">using OpenMDAO: om, make_component, DymosifiedCompWrapper

function main(; static_gravity)
  #
  # Initialize the Problem and the optimization driver
  #
  p = om.Problem(model=om.Group())
  p.driver = om.ScipyOptimizeDriver()
  p.driver.declare_coloring()
  #
  # Create a trajectory and add a phase to it
  #
  traj = p.model.add_subsystem(&quot;traj&quot;, dm.Trajectory())

  # `Trajectory.add_phase` expects a class that it can instantiate with the number of nodes used for the phase.
  # That&#39;s easy enough to create with an anonymous function, but unfortunatly it won&#39;t work with Dymos (because of the way JuliaCall implements truthiness/falsiness of Julia callables).
  # So, as a workaround, OpenMDAO.jl has a small wrapper `struct` that will fix this for us called `DymosifiedCompWrapper`.
  # The way this works: we give DymosifiedCompWrapper the ODE type (not a type instance, the type itself), and the keyword arguments we need to instantiate the type, other than `num_nodes`.
  # Check out the docstring for an example.
  dcw = DymosifiedCompWrapper(BrachistochroneODE; static_gravity=static_gravity)
  phase = traj.add_phase(&quot;phase0&quot;,
                         dm.Phase(ode_class = dcw,
                                  transcription = dm.GaussLobatto(num_segments=10)))

  #
  # Set the variables
  #
  phase.set_time_options(fix_initial=true, duration_bounds=(.5, 10))

  phase.add_state(&quot;x&quot;, fix_initial=true, fix_final=true)

  phase.add_state(&quot;y&quot;, fix_initial=true, fix_final=true)

  phase.add_state(&quot;v&quot;, fix_initial=true, fix_final=false)

  phase.add_control(&quot;theta&quot;, continuity=true, rate_continuity=true,
                    units=&quot;deg&quot;, lower=0.01, upper=179.9)

  phase.add_parameter(&quot;g&quot;, units=&quot;m/s**2&quot;, val=9.80665)

  #
  # Minimize time at the end of the phase
  #
  phase.add_objective(&quot;time&quot;, loc=&quot;final&quot;, scaler=10)
  #
  p.model.linear_solver = om.DirectSolver()
  #
  # Setup the Problem
  #
  p.setup()

  #
  # Set the initial values
  #
  p[&quot;traj.phase0.t_initial&quot;] = 0.0
  p[&quot;traj.phase0.t_duration&quot;] = 2.0

  p.set_val(&quot;traj.phase0.states:x&quot;, phase.interp(&quot;x&quot;, ys=[0, 10]))
  p.set_val(&quot;traj.phase0.states:y&quot;, phase.interp(&quot;y&quot;, ys=[10, 5]))
  p.set_val(&quot;traj.phase0.states:v&quot;, phase.interp(&quot;v&quot;, ys=[0, 9.9]))
  p.set_val(&quot;traj.phase0.controls:theta&quot;, phase.interp(&quot;theta&quot;, ys=[5, 100.5]))

  #
  # Solve for the optimal trajectory
  #
  dm.run_problem(p)

  # Check the results
  println(&quot;static_gravity = $static_gravity, elapsed time = $(p.get_val(&quot;traj.phase0.timeseries.time&quot;)[-1]) (should be 1.80164719)&quot;)
end

main(; static_gravity=false)
main(; static_gravity=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
--- Constraint Report [traj] ---
    --- phase0 ---
        None

Model viewer data has already been recorded for Driver.
Full total jacobian was computed 3 times, taking 0.914813 seconds.
Total jacobian shape: (40, 50)


Jacobian shape: (40, 50)  (18.65% nonzero)
FWD solves: 13   REV solves: 0
Total colors vs. total size: 13 vs 50  (74.0% improvement)

Sparsity computed using tolerance: 1e-25
Time to compute sparsity: 0.914813 sec.
Time to compute coloring: 0.036139 sec.
static_gravity = false, elapsed time = [1.80161673] (should be 1.80164719)
/home/runner/work/OpenMDAO.jl/OpenMDAO.jl/docs/.CondaPkg/env/lib/python3.11/site-packages/openmdao/recorders/sqlite_recorder.py:227: UserWarning:The existing case recorder file, dymos_solution.db, is being overwritten.
Optimization terminated successfully    (Exit mode 0)
            Current function value: 18.016167304638337
            Iterations: 24
            Function evaluations: 24
            Gradient evaluations: 24
Optimization Complete
-----------------------------------

--- Constraint Report [traj] ---
    --- phase0 ---
        None

Model viewer data has already been recorded for Driver.
Full total jacobian was computed 3 times, taking 0.043413 seconds.
Total jacobian shape: (40, 50)


Jacobian shape: (40, 50)  (18.65% nonzero)
FWD solves: 13   REV solves: 0
Total colors vs. total size: 13 vs 50  (74.0% improvement)

Sparsity computed using tolerance: 1e-25
Time to compute sparsity: 0.043413 sec.
Time to compute coloring: 0.039524 sec.
static_gravity = true, elapsed time = [1.80161673] (should be 1.80164719)</code></pre><p>At the end we see we got pretty much the same answer for the elapsed time as the Python example in the Dymos docs. (But not exactly the same, which is a bummer...)</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../shape_by_conn/">« Variable Shapes at Runtime</a><a class="docs-footer-nextpage" href="../reference/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Monday 12 June 2023 14:35">Monday 12 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

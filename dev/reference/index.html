<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · OpenMDAO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpenMDAO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simple_paraboloid/">A Simple Example</a></li><li><a class="tocitem" href="../nonlinear_circuit/">A More Complicated Example</a></li><li><a class="tocitem" href="../shape_by_conn/">Variable Shapes at Runtime</a></li><li><a class="tocitem" href="../brachistochrone/">A Simple Dymos Example</a></li><li><a class="tocitem" href="../auto_sparse_ad/">Auto-Sparse Examples</a></li><li><a class="tocitem" href="../matrix_free_ad/">Auto-Matrix-Free Examples</a></li><li class="is-active"><a class="tocitem" href>API Reference</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../dev_docs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/master/docs/src/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.MatrixFreeADExplicitComp-Tuple{Any, Any, ComponentArrays.ComponentVector, ComponentArrays.ComponentVector}" href="#OpenMDAOCore.MatrixFreeADExplicitComp-Tuple{Any, Any, ComponentArrays.ComponentVector, ComponentArrays.ComponentVector}"><code>OpenMDAOCore.MatrixFreeADExplicitComp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MatrixFreeADExplicitComp(ad_backend, f!, Y_ca::ComponentVector, X_ca::ComponentVector; params=nothing, force_mode=&quot;&quot;, disable_prep=false, units_dict=Dict{Symbol,String}(), tags_dict=Dict{Symbol,Vector{String}}(), shape_by_conn_dict=Dict{Symbol,Bool}(), copy_shape_dict=Dict{Symbol,Symbol}(), aviary_input_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_output_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_meta_data=Dict{String,Any}())</code></pre><p>Create a <code>MatrixFreeADExplicitComp</code> from a user-defined function and output and input <code>ComponentVector</code>s.</p><p><strong>Positional Arguments</strong></p><ul><li><code>ad_backend</code>: <code>&lt;:ADTypes.AbstractADType</code> automatic differentation &quot;backend&quot; library</li><li><code>f!</code>: function of the form <code>f!(Y_ca, X_ca, params)</code> which writes outputs to <code>Y_ca</code> using inputs <code>X_ca</code> and, optionally, parameters <code>params</code>.</li><li><code>Y_ca</code>: <code>ComponentVector</code> of outputs</li><li><code>X_ca</code>: <code>ComponentVector</code> of inputs</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>params</code>: parameters passed to the third argument to <code>f!</code>. Could be anything, or <code>nothing</code>, but the derivatives of <code>Y_ca</code> with respect to <code>params</code> will not be calculated</li><li><code>force_mode=&quot;&quot;</code>: If <code>&quot;fwd&quot;</code>, use <code>DifferentiationInterface.pushforward!</code> to compute the derivatives (aka perform a Jacobian-vector product). If <code>&quot;rev&quot;</code>, use <code>DifferentiationInterface.pullback!</code> to compute the derivatives (aka perform a vector-Jacobian product). If <code>&quot;&quot;</code>, use whatever would be faster, as determined by <code>DifferentiationInterface.pushforward_performance</code> and <code>DifferentiationInterface.pullback_performance</code>, prefering <code>pushforward</code>.</li><li><code>disable_prep</code>: if <code>true</code>, do not use either <code>prepare_pushforward</code> or <code>prepare_pullback</code> to create a <code>DifferentiationInterface.PushforwardPrep</code> or <code>PullbackPrep</code> object to accelerate the derivative calculation. Disabling prep can avoid correctness issues with ReverseDiff.jl, see <a href="https://juliadiff.org/ReverseDiff.jl/dev/api/#The-AbstractTape-API">the discussion of branching and the <code>AbstractTape</code> API</a>.</li><li><code>units_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to OpenMDAO units (expressed as <code>String</code>s)</li><li><code>tags_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Vector</code>s of OpenMDAO tags</li><li><code>shape_by_conn_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Bool</code>s indicating if the variable&#39;s shape (size) will be set dynamically by a connection</li><li><code>copy_shape_dict</code>: <code>Dict</code> mapping variable names to other variable names indicating the &quot;key&quot; symbol should take its size from the &quot;value&quot; symbol</li><li><code>aviary_input_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of input variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary input variables.</li><li><code>aviary_output_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of output variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary output variables.</li><li><code>aviary_meta_data::Dict{String,Any}</code>: mapping of Aviary variable names to aviary metadata. Currently only the <code>&quot;units&quot;</code> and <code>&quot;default_value&quot;</code> fields are used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/matrix_free_ad.jl#L40-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.MatrixFreeADExplicitComp-Tuple{Any, Any, ComponentArrays.ComponentVector}" href="#OpenMDAOCore.MatrixFreeADExplicitComp-Tuple{Any, Any, ComponentArrays.ComponentVector}"><code>OpenMDAOCore.MatrixFreeADExplicitComp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">MatrixFreeADExplicitComp(ad_backend, f, X_ca::ComponentVector; params=nothing, force_mode=&quot;&quot;, disable_prep=false, units_dict=Dict{Symbol,String}(), tags_dict=Dict{Symbol,Vector{String}}(), shape_by_conn_dict=Dict{Symbol,Bool}(), copy_shape_dict=Dict{Symbol,Symbol}(), aviary_input_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_output_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_meta_data=Dict{String,Any}())</code></pre><p>Create a <code>MatrixFreeADExplicitComp</code> from a user-defined function and output and input <code>ComponentVector</code>s.</p><p><strong>Positional Arguments</strong></p><ul><li><code>ad_backend</code>: <code>&lt;:ADTypes.AbstractADType</code> automatic differentation &quot;backend&quot; library</li><li><code>f</code>: function of the form <code>Y_ca = f(X_ca, params)</code> which returns outputs <code>Y_ca</code> using inputs <code>X_ca</code> and, optionally, parameters <code>params</code>.</li><li><code>X_ca</code>: <code>ComponentVector</code> of inputs</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>params</code>: parameters passed to the third argument to <code>f!</code>. Could be anything, or <code>nothing</code>, but the derivatives of <code>Y_ca</code> with respect to <code>params</code> will not be calculated</li><li><code>force_mode=&quot;&quot;</code>: If <code>&quot;fwd&quot;</code>, use <code>DifferentiationInterface.pushforward!</code> to compute the derivatives (aka perform a Jacobian-vector product). If <code>&quot;rev&quot;</code>, use <code>DifferentiationInterface.pullback!</code> to compute the derivatives (aka perform a vector-Jacobian product). If <code>&quot;&quot;</code>, use whatever would be faster, as determined by <code>DifferentiationInterface.pushforward_performance</code> and <code>DifferentiationInterface.pullback_performance</code>, prefering <code>pushforward</code>.</li><li><code>disable_prep</code>: if <code>true</code>, do not use either <code>prepare_pushforward</code> or <code>prepare_pullback</code> to create a <code>DifferentiationInterface.PushforwardPrep</code> or <code>PullbackPrep</code> object to accelerate the derivative calculation. Disabling prep can avoid correctness issues with ReverseDiff.jl, see <a href="https://juliadiff.org/ReverseDiff.jl/dev/api/#The-AbstractTape-API">the discussion of branching and the <code>AbstractTape</code> API</a>.</li><li><code>units_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to OpenMDAO units (expressed as <code>String</code>s)</li><li><code>tags_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Vector</code>s of OpenMDAO tags</li><li><code>shape_by_conn_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Bool</code>s indicating if the variable&#39;s shape (size) will be set dynamically by a connection</li><li><code>copy_shape_dict</code>: <code>Dict</code> mapping variable names to other variable names indicating the &quot;key&quot; symbol should take its size from the &quot;value&quot; symbol</li><li><code>aviary_input_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of input variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary input variables.</li><li><code>aviary_output_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of output variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary output variables.</li><li><code>aviary_meta_data::Dict{String,Any}</code>: mapping of Aviary variable names to aviary metadata. Currently only the <code>&quot;units&quot;</code> and <code>&quot;default_value&quot;</code> fields are used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/matrix_free_ad.jl#L97-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.PartialsData" href="#OpenMDAOCore.PartialsData"><code>OpenMDAOCore.PartialsData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PartialsData(of::String, wrt::String; &lt;keyword arguments&gt;)</code></pre><p>Create a PartialsData object for the derivative of variable <code>of</code> with respect to variable <code>wrt</code>.</p><p><code>PartialsData</code> objects are used to construct arguments to OpenMDAO&#39;s <code>Component.declare_partials</code> method. Specifically, a <code>PartialsData</code> object <code>pd</code> will eventually be used to call <code>Component.declare_partials</code> like this:</p><pre><code class="language-python hljs">Component.declare_partials(pd.of, pd.wrt, rows=pd.rows, cols=pd.cols, val=pd.val, method=pd.method)</code></pre><p>The <code>of</code> and <code>wrt</code> positional arguments are required and set the <code>of</code> and <code>wrt</code> fields. The value of the other <code>PartialsData</code> fields (e.g., <code>pd.rows</code>, <code>pd.val</code>, etc.) are set via constructor keyword arguments, here:</p><p><strong>Keyword Arguments</strong></p><ul><li><p><code>rows::Union{&lt;:AbstractVector{Int64},Nothing} = nothing</code>: row indices for each non-zero Jacobian entry, if not <code>nothing</code>.</p></li><li><p><code>cols::Union{&lt;:AbstractVector{Int64},Nothing} = nothing</code>: column indices for each non-zero Jacobian entry, if not <code>nothing</code>.</p></li><li><p><code>val::Union{Float64,&lt;:AbstractArray{Float64},Nothing} = nothing</code>: value of Jacobian, if not <code>nothing</code>.</p></li><li><p><code>method::String = &quot;exact&quot;</code>: method use to calcluate the partial derivative(s). Should be one of</p><ul><li><code>&quot;exact&quot;</code>: user-defined partial derivatives via <code>compute_partials!</code>, <code>linearize!</code>, etc.</li><li><code>&quot;fd&quot;</code>: finite difference approximation</li><li><code>&quot;cs&quot;</code>: complex step approximation</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/partials_data.jl#L13-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.PerturbedDenseSparsityDetector" href="#OpenMDAOCore.PerturbedDenseSparsityDetector"><code>OpenMDAOCore.PerturbedDenseSparsityDetector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PerturbedDenseSparsityDetector</code></pre><p>Tweaked version of <a href="https://gdalle.github.io/DifferentiationInterface.jl/DifferentiationInterface/stable/api/#DifferentiationInterface.DenseSparsityDetector"><code>DenseSparsityDetector</code></a> sparsity pattern detector satisfying the <a href="https://sciml.github.io/ADTypes.jl/stable/#Sparse-AD">detection API</a> of <a href="https://github.com/SciML/ADTypes.jl">ADTypes.jl</a> that evaluates the Jacobian multiple times using a perturbed input vector. Specifically, input vector <code>x</code> will be perturbed via</p><pre><code class="language-julia hljs">    x_perturb = (1 .+ rel_x_perturb.*perturb1).*x .+ perturb2.*abs_x_perturb</code></pre><p>where <code>perturb1</code> and <code>perturb2</code> are random <code>Vector</code>s of numbers ranging from <code>-0.5</code> to <code>0.5</code>, and <code>rel_x_perturb</code> and <code>abs_x_perturb</code> are relative and absolute perturbation magnitudes specified by the user.</p><p>All of the caveats associated with the performance of <code>DenseSparsityDetector</code> apply to <code>PerturbedDenseSparsityDetector</code>, since it essentially does the same thing as <code>DenseSparsityDetector</code> multiple times. The nonzeros in a Jacobian or Hessian are detected by computing the relevant matrix with <em>dense</em> AD, and thresholding the entries with a given tolerance (which can be numerically inaccurate). This process can be very slow, and should only be used if its output can be exploited multiple times to compute many sparse matrices.</p><div class="admonition is-danger"><header class="admonition-header">Danger</header><div class="admonition-body"><p>In general, the sparsity pattern you obtain can depend on the provided input <code>x</code>. If you want to reuse the pattern, make sure that it is input-agnostic. Perturbing the input vector should hopefully guard against getting &quot;unlucky&quot; and finding zero Jacobian entries that aren&#39;t actually zero for all <code>x</code>, but is of course problem-dependent.</p></div></div><p><strong>Fields</strong></p><ul><li><code>backend::AbstractADType</code> is the dense AD backend used under the hood</li><li><code>atol::Float64</code> is the minimum magnitude of a matrix entry to be considered nonzero</li><li><code>nevals::Int=3</code> is the number of times the Jacobian will be evaluated using the perturbed input <code>x</code></li><li><code>rel_x_perturb=0.001</code>: is the relative magnitude of the <code>x</code> perturbation.</li></ul><p><strong>Constructor</strong></p><pre><code class="nohighlight hljs">PerturbedDenseSparsityDetector(backend; atol, method=:iterative, nevals=3, rel_x_perturb=0.001, abs_x_perturb=0.0001)</code></pre><p>The keyword argument <code>method::Symbol</code> can be either:</p><ul><li><code>:iterative</code>: compute the matrix in a sequence of matrix-vector products (memory-efficient)</li><li><code>:direct</code>: compute the matrix all at once (memory-hungry but sometimes faster).</li></ul><p>Note that the constructor is type-unstable because <code>method</code> ends up being a type parameter of the <code>PerturbedDenseSparsityDetector</code> object (this is not part of the API and might change).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/utils.jl#L193-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.SparseADExplicitComp" href="#OpenMDAOCore.SparseADExplicitComp"><code>OpenMDAOCore.SparseADExplicitComp</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SparseADExplicitComp{InPlace,TAD,TCompute,TX,TY,TJ,TPrep,TXCS,TYCS,TAMD} &lt;: AbstractExplicitComp{InPlace}</code></pre><p>An <code>&lt;:AbstractADExplicitComp</code> for sparse Jacobians.</p><p><strong>Fields</strong></p><ul><li><code>ad_backend::TAD</code>: <code>&lt;:ADTypes.AutoSparse</code> automatic differentation &quot;backend&quot; library</li><li><code>compute_adable::TCompute</code>: function of the form <code>compute_adable(Y, X)</code> compatible with DifferentiationInterface.jl that performs the desired computation, where <code>Y</code> and <code>X</code> are <code>ComponentVector</code>s of outputs and inputs, respectively</li><li><code>X_ca::ComponentVector</code>: <code>ComponentVector</code> of inputs</li><li><code>Y_ca::ComponentVector</code>: <code>ComponentVector</code> of outputs</li><li><code>J_ca_sparse::ComponentMatrix</code>: Sparse <code>ComponentMatrix</code> of the Jacobian of <code>Y_ca</code> with respect to <code>X_ca</code></li><li><code>units_dict::Dict{Symbol,String}</code>: mapping of variable names to units. Can be an empty <code>Dict</code> if units are not desired.</li><li><code>tags_dict::Dict{Symbol,Vector{String}</code>: mapping of variable names to <code>Vector</code>s of <code>String</code>s specifing variable tags.</li><li><code>shape_by_conn_dict::Dict{Symbol,Bool}</code>: mapping of variable names to <code>Bool</code> indicating if the variable shape should be determined dynamically by a connection.</li><li><code>aviary_input_names::Dict{Symbol,String}</code>: mapping of input variable names to Aviary names.</li><li><code>aviary_output_names::Dict{Symbol,String}</code>: mapping of output variable names to Aviary names.</li><li><code>aviary_meta_data::Dict{String,Any}</code>: mapping of Aviary variable names to aviary metadata. Currently only the <code>&quot;units&quot;</code> and <code>&quot;default_value&quot;</code> fields are used.</li><li><code>prep::DifferentiationInterface.JacobianPrep</code>: <code>DifferentiationInterface.jl</code> &quot;preparation&quot; object</li><li><code>rcdict</code>: <code>Dict{Tuple{Symbol,Sympol}, Tuple{Vector{Int}, Vector{Int}}</code> mapping sub-Jacobians of the form <code>(:output_name, :input_name)</code> to <code>Vector</code>s of non-zero row and column indices (1-based)</li><li><code>X_ca::ComponentVector</code>: <code>ComplexF64</code> version of <code>X_ca</code> (for the complex-step method)</li><li><code>Y_ca::ComponentVector</code>: <code>ComplexF64</code> version of <code>Y_ca</code> (for the complex-step method)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/sparse_ad.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.SparseADExplicitComp-Union{Tuple{TAD}, Tuple{TAD, Any, ComponentArrays.ComponentVector, ComponentArrays.ComponentVector}} where TAD&lt;:ADTypes.AutoSparse" href="#OpenMDAOCore.SparseADExplicitComp-Union{Tuple{TAD}, Tuple{TAD, Any, ComponentArrays.ComponentVector, ComponentArrays.ComponentVector}} where TAD&lt;:ADTypes.AutoSparse"><code>OpenMDAOCore.SparseADExplicitComp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SparseADExplicitComp(ad_backend, f!, Y_ca::ComponentVector, X_ca::ComponentVector; params=nothing, units_dict=Dict{Symbol,String}(), tags_dict=Dict{Symbol,Vector{String}}(), shape_by_conn_dict=Dict{Symbol,Bool}(), copy_shape_dict=Dict{Symbol,Symbol}(), force_skip_prep=false, aviary_input_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_output_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_meta_data=Dict{String,Any}())</code></pre><p>Create a <code>SparseADExplicitComp</code> from a user-defined function and output and input <code>ComponentVector</code>s.</p><p><strong>Positional Arguments</strong></p><ul><li><code>ad_backend</code>: <code>&lt;:ADTypes.AutoSparse</code> automatic differentation &quot;backend&quot; library</li><li><code>f!</code>: function of the form <code>f!(Y_ca, X_ca, params)</code> which writes outputs to <code>Y_ca</code> using inputs <code>X_ca</code> and, optionally, parameters <code>params</code>.</li><li><code>Y_ca</code>: <code>ComponentVector</code> of outputs</li><li><code>X_ca</code>: <code>ComponentVector</code> of inputs</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>params</code>: parameters passed to the third argument to <code>f!</code>. Could be anything, or <code>nothing</code>, but the derivatives of <code>Y_ca</code> with respect to <code>params</code> will not be calculated</li><li><code>units_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to OpenMDAO units (expressed as <code>String</code>s)</li><li><code>tags_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Vector</code>s of OpenMDAO tags</li><li><code>shape_by_conn_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Bool</code>s indicating if the variable&#39;s shape (size) will be set dynamically by a connection</li><li><code>copy_shape_dict</code>: <code>Dict</code> mapping variable names to other variable names indicating the &quot;key&quot; symbol should take its size from the &quot;value&quot; symbol</li><li><code>force_skip_prep</code>: if true, defer creating internal arrays and other structs until the user calls <code>update_prep!</code></li><li><code>aviary_input_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of input variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary input variables.</li><li><code>aviary_output_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of output variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary output variables.</li><li><code>aviary_meta_data::Dict{String,Any}</code>: mapping of Aviary variable names to aviary metadata. Currently only the <code>&quot;units&quot;</code> and <code>&quot;default_value&quot;</code> fields are used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/sparse_ad.jl#L83-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.SparseADExplicitComp-Union{Tuple{TAD}, Tuple{TAD, Any, ComponentArrays.ComponentVector}} where TAD&lt;:ADTypes.AutoSparse" href="#OpenMDAOCore.SparseADExplicitComp-Union{Tuple{TAD}, Tuple{TAD, Any, ComponentArrays.ComponentVector}} where TAD&lt;:ADTypes.AutoSparse"><code>OpenMDAOCore.SparseADExplicitComp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">SparseADExplicitComp(ad_backend, f, X_ca::ComponentVector; params=nothing, units_dict=Dict{Symbol,String}(), tags_dict=Dict{Symbol,Vector{String}}(), shape_by_conn_dict=Dict{Symbol,Bool}(), copy_shape_dict=Dict{Symbol,Symbol}(), force_skip_prep=false, aviary_input_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_output_vars=Dict{Symbol,Dict{String,&lt;:Any}}(), aviary_meta_data=Dict{String,Any}())</code></pre><p>Create a <code>SparseADExplicitComp</code> from a user-defined function and output and input <code>ComponentVector</code>s.</p><p><strong>Positional Arguments</strong></p><ul><li><code>ad_backend</code>: <code>&lt;:ADTypes.AutoSparse</code> automatic differentation &quot;backend&quot; library</li><li><code>f</code>: function of the form <code>Y_ca = f(X_ca, params)</code> which returns outputs <code>Y_ca</code> using inputs <code>X_ca</code> and, optionally, parameters <code>params</code>.</li><li><code>X_ca</code>: <code>ComponentVector</code> of inputs</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>params</code>: parameters passed to the third argument to <code>f!</code>. Could be anything, or <code>nothing</code>, but the derivatives of <code>Y_ca</code> with respect to <code>params</code> will not be calculated</li><li><code>units_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to OpenMDAO units (expressed as <code>String</code>s)</li><li><code>tags_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Vector</code>s of OpenMDAO tags</li><li><code>shape_by_conn_dict</code>: <code>Dict</code> mapping variable names (as <code>Symbol</code>s) to <code>Bool</code>s indicating if the variable&#39;s shape (size) will be set dynamically by a connection</li><li><code>copy_shape_dict</code>: <code>Dict</code> mapping variable names to other variable names indicating the &quot;key&quot; symbol should take its size from the &quot;value&quot; symbol</li><li><code>force_skip_prep</code>: if true, defer creating internal arrays and other structs until the user calls <code>update_prep!</code></li><li><code>aviary_input_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of input variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary input variables.</li><li><code>aviary_output_vars::Dict{Symbol,Dict{String,&lt;:Any}}</code>: mapping of output variable names to a <code>Dict</code> that contains keys <code>name</code> and optionally <code>shape</code> defining the Aviary name and shape for Aviary output variables.</li><li><code>aviary_meta_data::Dict{String,Any}</code>: mapping of Aviary variable names to aviary metadata. Currently only the <code>&quot;units&quot;</code> and <code>&quot;default_value&quot;</code> fields are used.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/sparse_ad.jl#L139-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.VarData" href="#OpenMDAOCore.VarData"><code>OpenMDAOCore.VarData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VarData(name::String; &lt;keyword arguments&gt;)</code></pre><p>Create a VarData object for an OpenMDAO variable named <code>name</code>.</p><p><code>VarData</code> objects are used to construct arguments to OpenMDAO&#39;s <code>Component.add_input</code> and <code>Component.add_output</code> methods. Specifically, if a <code>VarData</code> object <code>var</code> refers to an input variable, the <code>Component.add_input</code> call will look like this:</p><pre><code class="language-python hljs">Component.add_input(var.name, shape=var.shape, val=var.val, units=var.units, tags=var.tags, shape_by_conn=var.shape_by_conn)</code></pre><p>and if the <code>VarData</code> object <code>var</code> is an output variable, the <code>Component.add_output</code> call will look like this:</p><pre><code class="language-python hljs">Component.add_output(var.name, shape=var.shape, val=var.val, units=var.units, lower=var.lower, upper=var.upper, tags=var.tags, shape_by_conn=var.shape_by_conn)</code></pre><p>The <code>name</code> positional argument is required and sets the <code>name</code> field. The value of the other <code>VarData</code> fields (e.g., <code>var.shape</code>, <code>var.val</code>, etc.) are set via constructor keyword arguments, here:</p><p><strong>Keyword Arguments</strong></p><ul><li><code>val::Union{Float64,&lt;:AbstractArray{Float64},Nothing} = 1.0</code>: variable&#39;s default value, set to <code>1.0</code> if <code>nothing</code>.</li><li><code>shape::Union{Int64,NTuple{N,Int64},Nothing} = (1,)</code>: variable shape, set to <code>(1,)</code> if <code>nothing</code>.</li><li><code>units::Union{String,Nothing} = nothing</code>: variable units.</li><li><code>lower::Union{Float64,&lt;:AbstractArray{Float64,N},Nothing} = nothing</code>: variable&#39;s lower limit.</li><li><code>upper::Union{Float64,&lt;:AbstractArray{Float64,N},Nothing} = nothing</code>: variable&#39;s upper limit.</li><li><code>tags::Union{&lt;:AbstractVector{String},Nothing} = nothing</code>: variable tags.</li><li><code>shape_by_conn::Bool = false</code>: if <code>true</code>, shape this variable by its connected output (if an input) or input (if an output)</li><li><code>copy_shape::Union{String,Nothing} = nothing</code>: if a string, shape this variable by the local variable indicated by <code>copy_shape</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/var_data.jl#L6-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.get_rows_cols-Tuple{}" href="#OpenMDAOCore.get_rows_cols-Tuple{}"><code>OpenMDAOCore.get_rows_cols</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_rows_cols(; ss_sizes::Dict{Symbol, Int}, of_ss::AbstractVector{Symbol}, wrt_ss::AbstractVector{Symbol})</code></pre><p>Get the non-zero row and column indices for a sparsity pattern defined by output subscripts <code>of_ss</code> and input subscripts <code>wrt_ss</code>.</p><p><code>ss_sizes</code> is a <code>Dict</code> mapping the subscript symbols in <code>of_ss</code> and <code>wrt_ss</code> to the size of each dimension the subscript symbols correspond to. The returned indices will be zero-based, which is what the OpenMDAO <code>declare_partials</code> method expects.</p><p><strong>Examples</strong></p><p>Diagonal partials for 1D output and 1D input, both with length <code>5</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;5), of_ss=[:i], wrt_ss=[:i])
([0, 1, 2, 3, 4], [0, 1, 2, 3, 4])</code></pre><p>1D output with length 2 depending on all elements of 1D input with length 3 (so not actually sparse).</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;2, :j=&gt;3), of_ss=[:i], wrt_ss=[:j])
([0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2])</code></pre><p>2D output with size <code>(2, 3)</code> and 1D input with size <code>2</code>, where each <code>i</code> output row only depends on the <code>i</code> input element.</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;2, :j=&gt;3), of_ss=[:i, :j], wrt_ss=[:i])
([0, 1, 2, 3, 4, 5], [0, 0, 0, 1, 1, 1])</code></pre><p>2D output with size <code>(2, 3)</code> and 1D input with size <code>3</code>, where each <code>j</code> output column only depends on the <code>j</code> input element.</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;2, :j=&gt;3), of_ss=[:i, :j], wrt_ss=[:j])
([0, 1, 2, 3, 4, 5], [0, 1, 2, 0, 1, 2])</code></pre><p>2D output with size <code>(2, 3)</code> depending on input with size <code>(3, 2)</code>, where the output element at index <code>i, j</code> only depends on input element <code>j, i</code> (like a transpose operation).</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;2, :j=&gt;3), of_ss=[:i, :j], wrt_ss=[:j, :i])
([0, 1, 2, 3, 4, 5], [0, 2, 4, 1, 3, 5])</code></pre><p>2D output with size <code>(2, 3)</code> depending on input with size <code>(3, 4)</code>, where output <code>y[:, j]</code> for each <code>j</code> depends on input <code>x[j, :]</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; rows, cols = get_rows_cols(; ss_sizes=Dict(:i=&gt;2, :j=&gt;3, :k=&gt;4), of_ss=[:i, :j], wrt_ss=[:j, :k]);

julia&gt; @show rows cols;  # to prevent abbreviating the array display
rows = [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5]
cols = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/utils.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAOCore.get_rows_cols_dict_from_sparsity-Tuple{ComponentArrays.ComponentMatrix}" href="#OpenMDAOCore.get_rows_cols_dict_from_sparsity-Tuple{ComponentArrays.ComponentMatrix}"><code>OpenMDAOCore.get_rows_cols_dict_from_sparsity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">get_rows_cols_dict_from_sparsity(J::ComponentMatrix)</code></pre><p>Get a <code>Dict</code> of the non-zero row and column indices for a sparsity pattern defined by a <code>ComponentMatrix</code> representation of a Jacobian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAOCore.jl/src/utils.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="OpenMDAO.make_component" href="#OpenMDAO.make_component"><code>OpenMDAO.make_component</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">make_component(comp::OpenMDAOCore.AbstractComp)</code></pre><p>Convinience method for creating either a <code>JuliaExplicitComp</code> or <code>JuliaImplicitComp</code>, depending on if <code>comp</code> is <code>&lt;:OpenMDAOCore.AbstractExplicitComp</code> or <code>&lt;:OpenMDAOCore.AbstractImplicitComp</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/83bc518169a2a3145bf9c7fb5f3ea54153e03e1b/julia/OpenMDAO.jl/src/OpenMDAO.jl#L23-L27">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../matrix_free_ad/">« Auto-Matrix-Free Examples</a><a class="docs-footer-nextpage" href="../limitations/">Limitations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 9 May 2025 17:09">Friday 9 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Variable Shapes at Runtime · OpenMDAO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpenMDAO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simple_paraboloid/">A Simple Example</a></li><li><a class="tocitem" href="../nonlinear_circuit/">A More Complicated Example</a></li><li class="is-active"><a class="tocitem" href>Variable Shapes at Runtime</a><ul class="internal"><li><a class="tocitem" href="#A-Simple-Example"><span>A Simple Example</span></a></li><li><a class="tocitem" href="#Sparsity-Patterns-with-get_rows_cols"><span>Sparsity Patterns with <code>get_rows_cols</code></span></a></li><li><a class="tocitem" href="#Back-to-the-Simple-Example"><span>Back to the Simple Example</span></a></li><li><a class="tocitem" href="#Checking"><span>Checking</span></a></li></ul></li><li><a class="tocitem" href="../brachistochrone/">A Simple Dymos Example</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../dev_docs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Variable Shapes at Runtime</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Variable Shapes at Runtime</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/master/docs/src/shape_by_conn.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Variable-Shapes-at-Runtime:-shape_by_conn-and-copy_shape"><a class="docs-heading-anchor" href="#Variable-Shapes-at-Runtime:-shape_by_conn-and-copy_shape">Variable Shapes at Runtime: <code>shape_by_conn</code> and <code>copy_shape</code></a><a id="Variable-Shapes-at-Runtime:-shape_by_conn-and-copy_shape-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Shapes-at-Runtime:-shape_by_conn-and-copy_shape" title="Permalink"></a></h1><h2 id="A-Simple-Example"><a class="docs-heading-anchor" href="#A-Simple-Example">A Simple Example</a><a id="A-Simple-Example-1"></a><a class="docs-heading-anchor-permalink" href="#A-Simple-Example" title="Permalink"></a></h2><p>OpenMDAO is able to <a href="https://openmdao.org/newdocs/versions/latest/features/experimental/dyn_shapes.html">determine variable shapes at runtime</a>. In &quot;normal&quot; (aka non-Julian) OpenMDAO, this is done via the <code>shape_by_conn</code> and <code>copy_shape</code> arguments to the venerable <code>add_input</code> and/or <code>add_output</code> <code>Component</code> methods. In OpenMDAO.jl, we can provide the <code>shape_by_conn</code> and/or <code>copy_shape</code> arguments to the <code>VarData</code> <code>struct</code> constructor to get the same behavior.</p><p>We&#39;ll show how this works using a simple <code>ExplicitComponent</code> that computes <span>$y = 2*x^2 + 1$</span> element-wise, where <span>$x$</span> and <span>$y$</span> are two-dimensional arrays of any (identical) size.</p><p>We&#39;ll need <code>OpenMDAOCore</code> of course, and need to declare our <code>ExplicitComponent</code> in the usual way:</p><pre><code class="language-julia hljs">using OpenMDAOCore: OpenMDAOCore

struct ECompShapeByConn &lt;: OpenMDAOCore.AbstractExplicitComp end</code></pre><p>Next we need a <code>setup</code> method:</p><pre><code class="language-julia hljs">function OpenMDAOCore.setup(self::ECompShapeByConn)
    input_data = [OpenMDAOCore.VarData(&quot;x&quot;; shape_by_conn=true)]
    output_data = [OpenMDAOCore.VarData(&quot;y&quot;; shape_by_conn=true, copy_shape=&quot;x&quot;)]

    partials_data = []
    return input_data, output_data, partials_data
end</code></pre><p>Notice how we provided the <code>shape_by_conn</code> argument to the <code>VarData</code> <code>struct</code> for <code>x</code>, and the <code>shape_by_conn</code> and <code>copy_shape</code> arguments to <code>y</code>&#39;s <code>VarData</code> <code>struct</code>. This means that the shape of <code>x</code> will be determined at runtime by OpenMDAO, and will be set to the shape of whatever output is connected to <code>x</code>. The shape of <code>y</code> will be set to that of <code>x</code>, since we provided the <code>copy_shape=&quot;x&quot;</code> argument. (Also notice how we returned an empty Vector for the <code>partials_data</code> output—OpenMDAO.jl always expects <code>OpenMDAOCore.setup</code> to return three Vectors, corresponding to <code>input_data</code>, <code>output_data</code>, and <code>partials_data</code>. But the <code>partials_data</code> Vector can be empty if it&#39;s not needed.)</p><p>Now, the derivative of <code>y</code> with respect to <code>x</code> will be sparse—the value of an element <code>y[i,j]</code> depends on the element <code>x[i,j]</code>, and no others. We can communicate this fact to OpenMDAO through the <code>rows</code> and <code>cols</code> arguments to <code>declare_partials</code> in Python OpenMDAO, or the <code>PartialsData</code> <code>struct</code> in OpenMDAO.jl. But how do we do that here, when we don&#39;t know the sizes of <code>x</code> and <code>y</code> in the <code>setup</code> method? The answer is we implement an <code>OpenMDAOCore.setup_partials</code> method, which gives us another chance to create more <code>PartialsData</code> <code>structs</code> after OpenMDAO has figured out what the sizes of all the inputs and outputs are:</p><pre><code class="language-julia hljs">function OpenMDAOCore.setup_partials(self::ECompShapeByConn, input_sizes, output_sizes)
    @assert input_sizes[&quot;x&quot;] == output_sizes[&quot;y&quot;]
    m, n = input_sizes[&quot;x&quot;]
    rows, cols = OpenMDAOCore.get_rows_cols(ss_sizes=Dict(:i=&gt;m, :j=&gt;n), of_ss=[:i, :j], wrt_ss=[:i, :j])
    partials_data = [OpenMDAOCore.PartialsData(&quot;y&quot;, &quot;x&quot;; rows=rows, cols=cols)]

    return partials_data
end</code></pre><p>The <code>OpenMDAOCore.setup_partials</code> method will always take an instance of the <code>OpenMDAOCore.AbstractComp</code> (called <code>self</code> here), and two <code>Dict</code>s, both with <code>String</code> keys and <code>NTuple{N, Int}</code> values. The keys indicate the name of an input or output variable, and the <code>NTuple{Int, N}</code> values are the shapes of each variable. The first <code>Dict</code> holds all the input shapes, and the second <code>Dict</code> has all the output shapes.</p><p>Now, the job of <code>setup_partials</code> is to return a <code>Vector</code> of <code>PartialsData</code> <code>structs</code>. We&#39;d like to include the <code>rows</code> and <code>cols</code> arguments to the <code>PartialsData</code> <code>struct</code> for the derivative of <code>y</code> with respect to <code>x</code>, but it&#39;s a bit tricky, since <code>x</code> and <code>y</code> are two-dimensional. Luckily, there is a small utility function provided by OpenMDAOCore.jl called <code>get_rows_cols</code> that can help us.</p><h2 id="Sparsity-Patterns-with-get_rows_cols"><a class="docs-heading-anchor" href="#Sparsity-Patterns-with-get_rows_cols">Sparsity Patterns with <code>get_rows_cols</code></a><a id="Sparsity-Patterns-with-get_rows_cols-1"></a><a class="docs-heading-anchor-permalink" href="#Sparsity-Patterns-with-get_rows_cols" title="Permalink"></a></h2><p>The <code>get_rows_cols</code> function uses a symbolic notation to express sparsity patterns in a simple way. Here&#39;s an example that corresponds to our present case. Let&#39;s say <code>x</code> and <code>y</code> have shape <code>(2, 3)</code>. Then the non-zero index combinations for the derivative of <code>y</code> with respect to <code>x</code> will be (using zero-based indices, which is what OpenMDAO expects for the <code>rows</code> and <code>cols</code> arguments):</p><pre><code class="nohighlight hljs">y indices:  x indices:
(0, 0)      (0, 0)
(0, 1)      (0, 1)
(0, 2)      (0, 2)
(1, 0)      (1, 0)
(1, 1)      (1, 1)
(1, 2)      (1, 2)</code></pre><p>So that table says that the value of <code>y[0, 0]</code> depends on <code>x[0, 0]</code> only, and the value of <code>y[1, 0]</code> depends on <code>x[1, 0]</code> only, etc.. But OpenMDAO expects flattened indices for the <code>rows</code> and <code>cols</code> arguments, not multi-dimensional indices. So we need to convert the multi-dimensional indices in that table to flattened ones. <code>get_rows_cols</code> does that for you, but if you wanted to do that by hand, what I usually do is think of an array having the same shape as each input or output, with each entry in the array corresponding to the entry&#39;s flat index. So for <code>x</code> and y, that would be:</p><pre><code class="nohighlight hljs">x_flat_indices =
[0 1 2;
 3 4 5]

y_flat_indices =
[0 1 2;
 3 4 5]</code></pre><p>(Remember that Python/NumPy arrays use row-major aka C ordering by default.) So we can now use those two arrays to translate the <code>y indices</code> and <code>x indices</code> from multi-dimensional to flat:</p><pre><code class="nohighlight hljs">y indices     x indices
multi, flat:  multi, flat:
(0, 0) 0      (0, 0) 0
(0, 1) 1      (0, 1) 1
(0, 2) 2      (0, 2) 2
(1, 0) 3      (1, 0) 3
(1, 1) 4      (1, 1) 4
(1, 2) 5      (1, 2) 5</code></pre><p>So the <code>rows</code> and <code>cols</code> arguments will be</p><pre><code class="nohighlight hljs">rows = [0, 1, 2, 3, 4, 5]
cols = [0, 1, 2, 3, 4, 5]</code></pre><p>where <code>rows</code> is the flat non-zero indices for <code>y</code>, and <code>cols</code> is the flat non-zero indices for <code>x</code>.</p><p>Now, how do we do this with <code>get_rows_cols</code>? First we have to assign labels to each dimension of <code>y</code> and <code>x</code>. The labels must be <code>Symbols</code>, and can be anything (but I usually use index-y things like <code>:i</code>, <code>:j</code>, <code>:k</code>, etc.). We express the sparsity pattern through the choice of labels. If we use a label for an output dimension that is also used for an input dimension, then we are saying that, for a given index <code>i</code> in the &quot;shared&quot; dimension, the value of the output at that index <code>i</code> depends on the value of the input index <code>i</code> along the labeled dimension, and no others. For example, if we had a one-dimensional <code>y</code> that was calculated from a one-dimensional <code>x</code> in this way:</p><pre><code class="nohighlight hljs">for i in 1:10
    y[i] = sin(x[i])
end</code></pre><p>then we would use the same label for the (single) output and input dimension.</p><p>For the present example, we could assign <code>i</code> and <code>j</code> (say) to the first and second dimensions, respectively, of both <code>y</code> and <code>x</code>, since <code>y[i,j]</code> only depends on <code>x[i,j]</code> for all valid <code>i</code> and <code>j</code>. We call these <code>of_ss</code> (short for &quot;of subscripts for the output) and <code>wrt_ss</code> (&quot;with respect to subscripts&quot;).</p><pre><code class="language-julia hljs">of_ss = [:i, :j]
wrt_ss = [:i, :j]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Symbol}:
 :i
 :j</code></pre><p>After deciding on the dimension labels, the only other thing we need to do is create a <code>Dict</code> that maps the dimension labels to their sizes:</p><pre><code class="language-julia hljs">ss_sizes = Dict(:i=&gt;2, :j=&gt;3)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Symbol, Int64} with 2 entries:
  :j =&gt; 3
  :i =&gt; 2</code></pre><p>since, in our example, the first dimension of <code>x</code> and <code>y</code> has size <code>2</code>, and the second, <code>3</code>.</p><p>Then we pass those three things to <code>get_rows_cols</code>, which then returns the <code>rows</code> and <code>cols</code> we want.</p><pre><code class="language-julia hljs">rows, cols = OpenMDAOCore.get_rows_cols(; ss_sizes, of_ss, wrt_ss)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([0, 1, 2, 3, 4, 5], [0, 1, 2, 3, 4, 5])</code></pre><h2 id="Back-to-the-Simple-Example"><a class="docs-heading-anchor" href="#Back-to-the-Simple-Example">Back to the Simple Example</a><a id="Back-to-the-Simple-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Back-to-the-Simple-Example" title="Permalink"></a></h2><p>Now, back to the simple example. Remember, we&#39;re trying to compute <code>y = 2*x^2 + 1</code> elementwise for a 2D <code>x</code> and <code>y</code>. The <code>compute!</code> method is pretty straight-forward:</p><pre><code class="language-julia hljs">function OpenMDAOCore.compute!(self::ECompShapeByConn, inputs, outputs)
    x = inputs[&quot;x&quot;]
    y = outputs[&quot;y&quot;]
    y .= 2 .* x.^2 .+ 1
    return nothing
end</code></pre><p>Now, for the <code>compute_partials!</code> method, we have to be a bit tricky about the shape of the Jacobian of <code>y</code> with respect to <code>x</code>. The <code>get_rows_cols</code> function orders the <code>rows</code> and <code>cols</code> in such a way that the Jacobian gets allocated by OpenMDAO with shape (<code>i</code>, <code>j</code>), and is then flattened. Since NumPy arrays are row-major ordered, then, we need to reshape the Jacobian in the opposite order, then switch the dimensions. This is optional, but makes things easier:</p><pre><code class="language-julia hljs">function OpenMDAOCore.compute_partials!(self::ECompShapeByConn, inputs, partials)
    x = inputs[&quot;x&quot;]
    m, n = size(x)
    # So, with the way I&#39;ve declared the partials above, OpenMDAO will have
    # created a Numpy array of shape (m, n) and then flattened it. So, to get
    # that to work, I&#39;ll need to do this:
    dydx = PermutedDimsArray(reshape(partials[&quot;y&quot;, &quot;x&quot;], n, m), (2, 1))
    dydx .= 4 .* x
    return nothing
end</code></pre><h2 id="Checking"><a class="docs-heading-anchor" href="#Checking">Checking</a><a id="Checking-1"></a><a class="docs-heading-anchor-permalink" href="#Checking" title="Permalink"></a></h2><p>Now, let&#39;s actually create a <code>Problem</code> with the new <code>Component</code>, along with an <code>IndepVarComp</code> that will actually decide on the size:</p><pre><code class="language-julia hljs">using OpenMDAO, PythonCall

m, n = 3, 4
p = om.Problem()
comp = om.IndepVarComp()
comp.add_output(&quot;x&quot;, shape=(m, n))
p.model.add_subsystem(&quot;inputs_comp&quot;, comp, promotes_outputs=[&quot;x&quot;])

ecomp = ECompShapeByConn()
comp = make_component(ecomp)
p.model.add_subsystem(&quot;ecomp&quot;, comp, promotes_inputs=[&quot;x&quot;], promotes_outputs=[&quot;y&quot;])
p.setup(force_alloc_complex=true)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Python: &lt;openmdao.core.problem.Problem object at 0x7f08181dbb90&gt;</code></pre><p>Now we should be able to check that the output we get is correct:</p><pre><code class="language-julia hljs">p.set_val(&quot;x&quot;, 1:m*n)
p.run_model()

# Test that the output is what we expect.
expected = 2 .* PyArray(p.get_val(&quot;x&quot;)).^2 .+ 1
actual = PyArray(p.get_val(&quot;y&quot;))
println(&quot;expected = $(expected)&quot;)
println(&quot;actual   = $(actual)&quot;)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">expected = [3.0 9.0 19.0 33.0; 51.0 73.0 99.0 129.0; 163.0 201.0 243.0 289.0]
actual   = [3.0 9.0 19.0 33.0; 51.0 73.0 99.0 129.0; 163.0 201.0 243.0 289.0]</code></pre><p>And we can check the derivatives:</p><pre><code class="language-julia hljs">p.check_partials(method=&quot;cs&quot;)
nothing</code></pre><p>Looks good!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nonlinear_circuit/">« A More Complicated Example</a><a class="docs-footer-nextpage" href="../brachistochrone/">A Simple Dymos Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 8 June 2023 18:38">Thursday 8 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

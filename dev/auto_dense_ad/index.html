<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Auto-Dense Examples · OpenMDAO.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">OpenMDAO.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../simple_paraboloid/">A Simple Example</a></li><li><a class="tocitem" href="../nonlinear_circuit/">A More Complicated Example</a></li><li><a class="tocitem" href="../shape_by_conn/">Variable Shapes at Runtime</a></li><li><a class="tocitem" href="../brachistochrone/">A Simple Dymos Example</a></li><li class="is-active"><a class="tocitem" href>Auto-Dense Examples</a><ul class="internal"><li><a class="tocitem" href="#The-User-Defined-Function"><span>The User-Defined Function</span></a></li><li><a class="tocitem" href="#DenseADExplicitComp-Paraboloid"><span><code>DenseADExplicitComp</code> Paraboloid</span></a></li></ul></li><li><a class="tocitem" href="../auto_sparse_ad/">Auto-Sparse Examples</a></li><li><a class="tocitem" href="../matrix_free_ad/">Auto-Matrix-Free Examples</a></li><li><a class="tocitem" href="../creating_python_packages/">Creating Python Packages That Use OpenMDAOCore.jl</a></li><li><a class="tocitem" href="../reference/">API Reference</a></li><li><a class="tocitem" href="../limitations/">Limitations</a></li><li><a class="tocitem" href="../dev_docs/">Developer Docs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Auto-Dense Examples</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Auto-Dense Examples</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/byuflowlab/OpenMDAO.jl/blob/master/docs/src/auto_dense_ad.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Automatic-Dense-AD"><a class="docs-heading-anchor" href="#Automatic-Dense-AD">Automatic Dense AD</a><a id="Automatic-Dense-AD-1"></a><a class="docs-heading-anchor-permalink" href="#Automatic-Dense-AD" title="Permalink"></a></h1><p>OpenMDAOCore.jl can create explicit components that are differentiated automatically by the AD packages supported by <a href="https://github.com/JuliaDiff/DifferentiationInterface.jl">DifferentiationInterface.jl</a>. Three approaches to differentiating the components are supported:</p><ul><li>Dense AD, where we assume the Jacobian is dense</li><li>Sparse AD, where we assume the Jacobian is sparse, and use the sparsity pattern to accelerate the differentiation</li><li>Matrix-free AD, where we perform Jacobian-vector or vector-Jacobian products instead of forming the entire Jacobian</li></ul><p>This page will describe the first and simplest approach (dense AD), with the next couple of pages getting into the others.</p><h2 id="The-User-Defined-Function"><a class="docs-heading-anchor" href="#The-User-Defined-Function">The User-Defined Function</a><a id="The-User-Defined-Function-1"></a><a class="docs-heading-anchor-permalink" href="#The-User-Defined-Function" title="Permalink"></a></h2><p>The interface for the AD functionality in OpenMDAO.jl is a bit different from the &quot;plain&quot; <code>AbstractExplicitComp</code> and <code>AbstractImplicitComp</code> <code>struct</code>s described in earlier examples (see <a href="../simple_paraboloid/#A-Simple-Example:-Optimizing-a-Paraboloid">A Simple Example: Optimizing a Paraboloid</a> or <a href="../nonlinear_circuit/#A-More-Complicated-Example:-Nonlinear-Circuit">A More Complicated Example: Nonlinear Circuit</a>). Instead of creating subtypes of <code>AbstractExplicitComp</code> that implement <code>OpenMDAOCore.setup</code>, <code>OpenMDAOCore.compute!</code>, etc., we&#39;ll be writing a Julia function that performs our desired computation. This user-defined function will then be passed to a constructor of the <code>DenseADExplicitComp</code> <code>struct</code>, which will implement the necessary <code>OpenMDAOCore</code> methods for us. (The same user-defined function can also be used for the sparse AD and matrix-free AD approaches, making it relatively simple to try all three out to see what&#39;s fastest!)</p><p>The user-defined function <em>must</em> follow one of two forms: either it can be an &quot;in-place&quot; function that writes its outputs to an output vector, or it can be an &quot;out-of-place&quot; function that returns a single output vector. Both types must also have a <code>params</code> argument that will contain inputs that are needed for the calculation, but won&#39;t be differentiated. So, an example of an in-place function would be </p><pre><code class="nohighlight hljs">function f_in_place!(Y, X, params)
   # calculate stuff with X and params, storing result in Y
   return nothing
end</code></pre><p>where <code>X</code> is the input vector and <code>Y</code> is the output vector. (The function doesn&#39;t have to return <code>nothing</code>, but any returned value will be ignored, so I like to include <code>return nothing</code> to make it clear that the return value doesn&#39;t matter.) An out-of-place function would look like</p><pre><code class="nohighlight hljs">function f_out_of_place(X, params)
   # calculate stuff with X and params, returning Y
   return Y
end</code></pre><p>where again <code>X</code> is the input vector.</p><p>Now, the <code>X</code> and <code>Y</code> arguments of those functions must not be plain Julia <code>Vector</code>s, but <code>ComponentVectors</code> from the <a href="https://github.com/jonniedie/ComponentArrays.jl">ComponentArrays.jl</a> package. What are those? They are objects provided by the <a href="https://github.com/SciML/ComponentArrays.jl">ComponentArrays.jl</a> package that act like <code>Vector</code>s, but allow the user to define names for each part (&quot;component&quot;) of the vector. For example:</p><pre><code class="language-julia hljs">using ComponentArrays: ComponentVector

x1 = ComponentVector(foo=-1.0, bar=-2.0, baz=-3.0)
@show x1 x1[3] x1.foo x1[:foo]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x1 = (foo = -1.0, bar = -2.0, baz = -3.0)
x1[3] = -3.0
x1.foo = -1.0
x1[:foo] = -1.0</code></pre><p>Notice that we can get, say, the third value of <code>x1</code> the usual way (<code>x1[3]</code>), but also by referring to the <code>foo</code> field value via <code>x1.foo</code> and by indexing the <code>ComponentVector</code> with the symbol <code>:foo</code> (<code>x1[:foo]</code>).</p><p>Each of the components in <code>x1</code> are scalars, but they don&#39;t have to be:</p><pre><code class="language-julia hljs">x2 = ComponentVector(foo=-1.0, bar=1:4, baz=reshape(5:10, 2, 3))
@show x2 x2[:foo] x2[:bar] x2[:baz]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x2 = (foo = -1.0, bar = [1.0, 2.0, 3.0, 4.0], baz = [5.0 7.0 9.0; 6.0 8.0 10.0])
x2[:foo] = -1.0
x2[:bar] = [1.0, 2.0, 3.0, 4.0]
x2[:baz] = [5.0 7.0 9.0; 6.0 8.0 10.0]</code></pre><p>In <code>x2</code>, the <code>foo</code> component is a scalar, <code>bar</code> refers to a <code>Vector</code> (aka a 1D <code>Array</code>) and <code>baz</code> refers to a <code>Matrix</code> (aka a 2D Array). But <code>x2</code> still &quot;looks like&quot; a <code>Vector</code>:</p><pre><code class="language-julia hljs">@show x2[3]  # will give the third value of `x2`, which happens to be the second value of x2[:bar]
@show ndims(x2)  # Should be 1, since a Vector is 1-dimensional
@show length(x2)  # length(x2) gives the total number of entries in `x2`, aka 1 + 4 + 2*3 = 11
@show size(x2)  # size is a length-1 tuple since a Vector has just one dimension</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">x2[3] = 2.0
ndims(x2) = 1
length(x2) = 11
size(x2) = (11,)</code></pre><p>Now, how will we use <code>ComponentVector</code>s here? We&#39;ll use them to define the names and sizes of all the inputs and outputs to our component. For example, with the paraboloid component in <a href="../simple_paraboloid/#A-Simple-Example:-Optimizing-a-Paraboloid">A Simple Example: Optimizing a Paraboloid</a>, we created one component with two inputs <code>x</code> and <code>y</code> and one output <code>f_xy</code>, all scalars. So for that case, our <code>X_ca</code> would be</p><pre><code class="language-julia hljs">X_ca = ComponentVector(x=1.0, y=1.0)
Y_ca = ComponentVector(f_xy=0.0)
@show X_ca Y_ca</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">X_ca = (x = 1.0, y = 1.0)
Y_ca = (f_xy = 0.0)</code></pre><p>Actually, why don&#39;t we try to implement the <code>Paraboloid</code> component using a <code>DenseADExplicitComp</code>?</p><h2 id="DenseADExplicitComp-Paraboloid"><a class="docs-heading-anchor" href="#DenseADExplicitComp-Paraboloid"><code>DenseADExplicitComp</code> Paraboloid</a><a id="DenseADExplicitComp-Paraboloid-1"></a><a class="docs-heading-anchor-permalink" href="#DenseADExplicitComp-Paraboloid" title="Permalink"></a></h2><p>We&#39;ll start fresh, first with importing the stuff we&#39;ll need:</p><pre><code class="language-julia hljs">using ADTypes: ADTypes
using ComponentArrays: ComponentVector
using OpenMDAOCore: OpenMDAOCore
using OpenMDAO: make_component</code></pre><p>Next, we need to define the function that implements our paraboloid equation, which, again, is</p><p class="math-container">\[f(x,y) = (x - 3.0)^2 + xy + (y + 4.0)^2 - 3.0\]</p><p>That would look like this:</p><pre><code class="language-julia hljs">function f_paraboloid!(Y_ca, X_ca, params)
    # Get the inputs:
    x = @view(X_ca[:x])
    y = @view(X_ca[:y])
    # Could also do this:
    # x = X_ca.x
    # y = X_ca.y
    # or even this
    # (; x, y) = X_ca

    # Get the output:
    f_xy = @view(Y_ca[:f_xy])
    # Again, could also do this:
    # f_xy = Y_ca.f_xy
    # or
    # (; f_xy) = Y_ca

    # Do the calculation:
    @. f_xy = (x - 3.0)^2 + x*y + (y + 4.0)^2 - 3.0

    # Return value doesn&#39;t matter.
    return nothing
end</code></pre><ul><li>The <code>@view</code> macro is used when extracting the inputs and outputs from the <code>X_ca</code> and <code>Y_ca</code> <code>ComponentVector</code>s. This creates a view into the original <code>ComponentVector</code>, instead of a new array with a copy of the original data, which avoids unnecessary allocations and (for the outputs) allows modifications to the view to be reflected in the <code>Y_ca</code> array. In this example everything is a scalar, so no allocations would have happened anyway. But it doesn&#39;t hurt to use <code>@view</code>: it&#39;s a good habit to get into, <em>and</em> it allows us to use the <code>@.</code> <a href="https://docs.julialang.org/en/v1/manual/arrays/#Broadcasting">broadcasting</a> macro with the scalar <code>f_xy</code> output.</li><li>The <code>params</code> argument is not used in this example, but it is still required, since the <code>DenseADExplicitComp</code> constructor will expect the function to accept it. Also needed for <code>SparseADExplicitComp</code> and <code>MatrixFreeADExplicitComp</code>.</li></ul><p>Our next step is to create the <code>ComponentVector</code>s that will be used to hold the inputs and outputs:</p><pre><code class="language-julia hljs">X_ca = ComponentVector(x=1.0, y=1.0)
Y_ca = ComponentVector(f_xy=0.0)
@show X_ca Y_ca</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">X_ca = (x = 1.0, y = 1.0)
Y_ca = (f_xy = 0.0)</code></pre><div class="admonition is-warning"><header class="admonition-header">Use sane values for `X_ca` and `Y_ca`</header><div class="admonition-body"><p>The values of the entries in <code>X_ca</code> and <code>Y_ca</code> will be passed as initial values when creating the OpenMDAO <code>ExplicitComponent</code>. Depending on your application they may affect e.g. initial guesses for nonlinear solvers or determining the sparsity pattern of your <code>System</code>.</p></div></div><p>Now we&#39;re almost ready to create the <code>SparseADExplicitComp</code>. The last step is to decide what AD library to use. OpenMDAOCore.jl relies on the <a href="https://github.com/SciML/ADTypes.jl">ADTypes.jl</a> and DifferentiationInterface.jl packages for implementing the interface for calling the AD. Theoretically we can use any AD that those packages support. We&#39;ll use <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> for this example, which is a popular and very robust forward-mode AD:</p><pre><code class="language-julia hljs">using ForwardDiff: ForwardDiff
ad_backend = ADTypes.AutoForwardDiff()</code></pre><p>Now we are finally ready to create the component:</p><pre><code class="language-julia hljs">comp = OpenMDAOCore.DenseADExplicitComp(ad_backend, f_paraboloid!, Y_ca, X_ca; params=nothing)
parab_comp = make_component(comp)</code></pre><p><code>make_component</code> will convert the <code>DenseADExplicitComp</code> into a OpenMDAO Python component that we can use with OpenMDAO. So now we just need to proceed with the paraboloid example as usual:</p><pre><code class="language-julia hljs">using OpenMDAO: om

model = om.Group()
model.add_subsystem(&quot;parab_comp&quot;, parab_comp)

prob = om.Problem(model)

prob.driver = om.ScipyOptimizeDriver()
prob.driver.options[&quot;optimizer&quot;] = &quot;SLSQP&quot;

prob.model.add_design_var(&quot;parab_comp.x&quot;)
prob.model.add_design_var(&quot;parab_comp.y&quot;)
prob.model.add_objective(&quot;parab_comp.f_xy&quot;)

prob.setup(force_alloc_complex=true)

prob.set_val(&quot;parab_comp.x&quot;, 3.0)
prob.set_val(&quot;parab_comp.y&quot;, -4.0)

prob.run_model()
println(prob[&quot;parab_comp.f_xy&quot;])  # Should print `[-15.]`

prob.set_val(&quot;parab_comp.x&quot;, 5.0)
prob.set_val(&quot;parab_comp.y&quot;, -2.0)

prob.run_model()
println(prob.get_val(&quot;parab_comp.f_xy&quot;))  # Should print `[-5.]`</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">/home/runner/work/OpenMDAO.jl/OpenMDAO.jl/docs/.CondaPkg/.pixi/envs/default/lib/python3.13/site-packages/openmdao/visualization/n2_viewer/n2_viewer.py:115: OpenMDAOWarning:&#39;float&#39; object has no attribute &#39;shape&#39;
-15.0
-5.0</code></pre><p>Looks OK so far. But we should check our derivatives, just to be safe. We can do that with the finite difference method:</p><pre><code class="language-julia hljs">println(prob.check_partials(method=&quot;fd&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{&#39;parab_comp&#39;: {(&#39;f_xy&#39;, &#39;x&#39;): {&#39;J_fwd&#39;: array([[2.]]), &#39;J_fd&#39;: array([[2.000001]]), &#39;rows&#39;: None, &#39;cols&#39;: None, &#39;tol violation&#39;: _ErrorData(forward=-9.99632543852158e-07, reverse=None, fwd_rev=None), &#39;magnitude&#39;: _MagnitudeData(forward=2.0, reverse=0.0, fd=2.0000010003684565), &#39;vals_at_max_error&#39;: _ErrorData(forward=(np.float64(2.0), np.float64(2.0000010003684565)), reverse=None, fwd_rev=None), &#39;abs error&#39;: _ErrorData(forward=1.0003684565162985e-06, reverse=None, fwd_rev=None), &#39;rel error&#39;: _ErrorData(forward=5.001839780740122e-07, reverse=None, fwd_rev=None)}, (&#39;f_xy&#39;, &#39;y&#39;): {&#39;J_fwd&#39;: array([[9.]]), &#39;J_fd&#39;: array([[9.000001]]), &#39;rows&#39;: None, &#39;cols&#39;: None, &#39;tol violation&#39;: _ErrorData(forward=-7.999542276593274e-06, reverse=None, fwd_rev=None), &#39;magnitude&#39;: _MagnitudeData(forward=9.0, reverse=0.0, fd=9.000001000458724), &#39;vals_at_max_error&#39;: _ErrorData(forward=(np.float64(9.0), np.float64(9.000001000458724)), reverse=None, fwd_rev=None), &#39;abs error&#39;: _ErrorData(forward=1.0004587238654494e-06, reverse=None, fwd_rev=None), &#39;rel error&#39;: _ErrorData(forward=1.1116206807248763e-07, reverse=None, fwd_rev=None)}}}</code></pre><p>or the complex-step method:</p><pre><code class="language-julia hljs">println(prob.check_partials(method=&quot;cs&quot;))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">{&#39;parab_comp&#39;: {(&#39;f_xy&#39;, &#39;x&#39;): {&#39;J_fwd&#39;: array([[2.]]), &#39;J_fd&#39;: array([[2.]]), &#39;rows&#39;: None, &#39;cols&#39;: None, &#39;tol violation&#39;: _ErrorData(forward=-2e-06, reverse=None, fwd_rev=None), &#39;magnitude&#39;: _MagnitudeData(forward=2.0, reverse=0.0, fd=2.0), &#39;vals_at_max_error&#39;: _ErrorData(forward=(np.float64(2.0), np.float64(2.0)), reverse=None, fwd_rev=None), &#39;abs error&#39;: _ErrorData(forward=0.0, reverse=None, fwd_rev=None), &#39;rel error&#39;: _ErrorData(forward=0.0, reverse=None, fwd_rev=None)}, (&#39;f_xy&#39;, &#39;y&#39;): {&#39;J_fwd&#39;: array([[9.]]), &#39;J_fd&#39;: array([[9.]]), &#39;rows&#39;: None, &#39;cols&#39;: None, &#39;tol violation&#39;: _ErrorData(forward=-9e-06, reverse=None, fwd_rev=None), &#39;magnitude&#39;: _MagnitudeData(forward=9.0, reverse=0.0, fd=9.0), &#39;vals_at_max_error&#39;: _ErrorData(forward=(np.float64(9.0), np.float64(9.0)), reverse=None, fwd_rev=None), &#39;abs error&#39;: _ErrorData(forward=0.0, reverse=None, fwd_rev=None), &#39;rel error&#39;: _ErrorData(forward=0.0, reverse=None, fwd_rev=None)}}}</code></pre><p>Derivatives look great, so let&#39;s go ahead and perform the optimization:</p><pre><code class="language-julia hljs">prob.run_driver()
println(&quot;f_xy = $(prob.get_val(&quot;parab_comp.f_xy&quot;))&quot;)  # Should print `[-27.333333]`
println(&quot;x = $(prob.get_val(&quot;parab_comp.x&quot;))&quot;)  # Should print `[6.666666]`
println(&quot;y = $(prob.get_val(&quot;parab_comp.y&quot;))&quot;)  # Should print `[-7.333333]`</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-----------------------------------------
Component: JuliaExplicitComp &#39;parab_comp&#39;
-----------------------------------------

  parab_comp: &#39;f_xy&#39; wrt &#39;x&#39;

    Max Tolerance Violation (Jfwd - Jfd) - (atol + rtol * Jfd) : (-9.996325e-07)
      abs error: 1.000368e-06
      rel error: 5.001840e-07
      fwd value @ max viol: 2.000000e+00
      fd value @ max viol: 2.000001e+00 (fd:forward)

    Raw Forward Derivative (Jfwd)
    [[ 2.000000000000e+00]]

    Raw FD Derivative (Jfd)
    [[ 2.000001000368e+00]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  parab_comp: &#39;f_xy&#39; wrt &#39;y&#39;

    Max Tolerance Violation (Jfwd - Jfd) - (atol + rtol * Jfd) : (-7.999542e-06)
      abs error: 1.000459e-06
      rel error: 1.111621e-07
      fwd value @ max viol: 9.000000e+00
      fd value @ max viol: 9.000001e+00 (fd:forward)

    Raw Forward Derivative (Jfwd)
    [[ 9.000000000000e+00]]

    Raw FD Derivative (Jfd)
    [[ 9.000001000459e+00]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

-----------------------------------------
Component: JuliaExplicitComp &#39;parab_comp&#39;
-----------------------------------------

  parab_comp: &#39;f_xy&#39; wrt &#39;x&#39;

    Max Tolerance Violation (Jfwd - Jfd) - (atol + rtol * Jfd) : (-2.000000e-06)
      abs error: 0.000000e+00
      rel error: 0.000000e+00
      fwd value @ max viol: 2.000000e+00
      fd value @ max viol: 2.000000e+00 (cs:None)

    Raw Forward Derivative (Jfwd)
    [[ 2.000000000000e+00]]

    Raw CS Derivative (Jfd)
    [[ 2.000000000000e+00]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

  parab_comp: &#39;f_xy&#39; wrt &#39;y&#39;

    Max Tolerance Violation (Jfwd - Jfd) - (atol + rtol * Jfd) : (-9.000000e-06)
      abs error: 0.000000e+00
      rel error: 0.000000e+00
      fwd value @ max viol: 9.000000e+00
      fd value @ max viol: 9.000000e+00 (cs:None)

    Raw Forward Derivative (Jfwd)
    [[ 9.000000000000e+00]]

    Raw CS Derivative (Jfd)
    [[ 9.000000000000e+00]]

 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

f_xy = -27.333333333333336
x = [6.66666667]
y = [-7.33333333]</code></pre><p>Victory!</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../brachistochrone/">« A Simple Dymos Example</a><a class="docs-footer-nextpage" href="../auto_sparse_ad/">Auto-Sparse Examples »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 3 December 2025 18:02">Wednesday 3 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
